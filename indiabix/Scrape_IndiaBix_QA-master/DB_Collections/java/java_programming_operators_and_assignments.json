{"test_questions": [[{"question": "What will be the output of the program?\nclass PassA \n{\n    public static void main(String [] args) \n    {\n        PassA p = new PassA();\n        p.start();\n    }\n\n    void start() \n    {\n        long [] a1 = {3,4,5};\n        long [] a2 = fix(a1);\n        System.out.print(a1[0] + a1[1] + a1[2] + \" \");\n        System.out.println(a2[0] + a2[1] + a2[2]);\n    }\n\n    long [] fix(long [] a3) \n    {\n        a3[1] = 7;\n        return a3;\n    }\n}", "opta": "12 15", "optb": "15 15", "optc": "3 4 5 3 7 5", "optd": "3 7 5 3 7 5", "ans": "B", "explanation": "Output: 15 15\nThe reference variables a1 and a3 refer to the same long array object. When the [1] element is updated in the fix() method, it is updating the array referred to by a1. The reference variable a2 refers to the same array object.\nSo Output: 3+7+5+\" \"3+7+5\nOutput: 15 15 Because Numeric values will be added"}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        Test p = new Test();\n        p.start();\n    }\n\n    void start() \n    {\n        boolean b1 = false;\n        boolean b2 = fix(b1);\n        System.out.println(b1 + \" \" + b2);\n    }\n\n    boolean fix(boolean b1) \n    {\n        b1 = true;\n        return b1;\n    }\n}", "opta": "true true", "optb": "false true", "optc": "true false", "optd": "false false", "ans": "B", "explanation": "The boolean b1 in the fix() method is a different boolean than the b1 in the start() method. The b1 in the start() method is not updated by the fix() method."}, {"question": "What will be the output of the program?\nclass PassS \n{\n    public static void main(String [] args) \n    {\n        PassS p = new PassS();\n        p.start();\n    }\n\n    void start() \n    {\n        String s1 = \"slip\";\n        String s2 = fix(s1);\n        System.out.println(s1 + \" \" + s2);\n    }\n\n    String fix(String s1) \n    {\n        s1 = s1 + \"stream\";\n        System.out.print(s1 + \" \");\n        return \"stream\";\n    }\n}", "opta": "slip stream", "optb": "slipstream stream", "optc": "stream slip stream", "optd": "slipstream slip stream", "ans": "D", "explanation": "When the fix() method is first entered, start()'s s1 and fix()'s s1 reference variables both refer to the same String object (with a value of \"slip\"). Fix()'s s1 is reassigned to a new object that is created when the concatenation occurs (this second String object has a value of \"slipstream\"). When the program returns to start(), another String object is created, referred to by s2 and with a value of \"stream\"."}, {"question": "What will be the output of the program?\nclass BitShift \n{\n    public static void main(String [] args) \n    {\n        int x = 0x80000000;\n        System.out.print(x + \" and  \");\n        x = x >>> 31;\n        System.out.println(x);\n    }\n}", "opta": "-2147483648 and 1", "optb": "0x80000000 and 0x00000001", "optc": "-2147483648 and -1", "optd": "1 and -2147483648", "ans": "A", "explanation": "Option A is correct. The >>> operator moves all bits to the right, zero filling the left bits. The bit transformation looks like this:\nBefore: 1000 0000 0000 0000 0000 0000 0000 0000\nAfter: 0000 0000 0000 0000 0000 0000 0000 0001\nOption C is incorrect because the >>> operator zero fills the left bits, which in this case changes the sign of x, as shown.\nOption B is incorrect because the output method print() always displays integers in base 10.\nOption D is incorrect because this is the reverse order of the two output numbers."}, {"question": "What will be the output of the program?\nclass Equals \n{\n    public static void main(String [] args) \n    {\n        int x = 100;\n        double y = 100.1;\n        boolean b = (x = y); /* Line 7 */\n        System.out.println(b);\n    }\n}", "opta": "true", "optb": "false", "optc": "Compilation fails", "optd": "An exception is thrown at runtime", "ans": "C", "explanation": "The code will not compile because in line 7, the line will work only if we use (x==y) in the line. The == operator compares values to produce a boolean, whereas the = operator assigns a value to variables.\nOption A, B, and D are incorrect because the code does not get as far as compiling. If we corrected this code, the output would be false."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x=20;\n        String sup = (x < 15) ? \"small\" : (x < 22)? \"tiny\" : \"huge\";\n        System.out.println(sup);\n    }\n}", "opta": "small", "optb": "tiny", "optc": "huge", "optd": "Compilation fails", "ans": "B", "explanation": "This is an example of a nested ternary operator. The second evaluation (x < 22) is true, so the \"tiny\" value is assigned to sup."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x= 0;\n        int y= 0;\n        for (int z = 0; z < 5; z++) \n        {\n            if (( ++x > 2 ) && (++y > 2)) \n            {\n                x++;\n            }\n        }\n        System.out.println(x + \" \" + y);\n    }\n}", "opta": "5 2", "optb": "5 3", "optc": "6 3", "optd": "6 4", "ans": "C", "explanation": "In the first two iterations x is incremented once and y is not because of the short circuit && operator. In the third and forth iterations x and y are each incremented, and in the fifth iteration x is doubly incremented and y is incremented."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x= 0;\n        int y= 0;\n        for (int z = 0; z < 5; z++) \n        {\n            if (( ++x > 2 ) || (++y > 2)) \n            {\n                x++;\n            }\n        }\n    System.out.println(x + \" \" + y);\n    }\n}", "opta": "5 3", "optb": "8 2", "optc": "8 3", "optd": "8 5", "ans": "B", "explanation": "The first two iterations of the for loop both x and y are incremented. On the third iteration x is incremented, and for the first time becomes greater than 2. The short circuit or operator || keeps y from ever being incremented again and x is incremented twice on each of the last three iterations."}, {"question": "What will be the output of the program?\nclass Bitwise \n{\n    public static void main(String [] args) \n    {\n        int x = 11 & 9;\n        int y = x ^ 3;\n        System.out.println( y | 12 );\n    }\n}", "opta": "0", "optb": "7", "optc": "8", "optd": "14", "ans": "D", "explanation": "The & operator produces a 1 bit when both bits are 1. The result of the & operation is 9. The ^ operator produces a 1 bit when exactly one bit is 1; the result of this operation is 10. The | operator produces a 1 bit when at least one bit is 1; the result of this operation is 14."}, {"question": "What will be the output of the program?\nclass SSBool \n{\n    public static void main(String [] args) \n    {\n        boolean b1 = true;\n        boolean b2 = false;\n        boolean b3 = true;\n        if ( b1 & b2 | b2 & b3 | b2 ) /* Line 8 */\n            System.out.print(\"ok \");\n        if ( b1 & b2 | b2 & b3 | b2 | b1 ) /*Line 10*/\n            System.out.println(\"dokey\");\n    }\n}", "opta": "ok", "optb": "dokey", "optc": "ok dokey", "optd": "No output is produced", "opte": "Compilation error", "ans": "B", "explanation": "The & operator has a higher precedence than the | operator so that on line 8 b1 and b2 are evaluated together as are b2 & b3. The final b1 in line 10 is what causes that if test to be true. Hence it prints \"dokey\"."}, {"question": "What will be the output of the program?\nclass SC2 \n{\n    public static void main(String [] args) \n    {\n        SC2 s = new SC2();\n        s.start();\n    }\n\n    void start() \n    {\n        int a = 3;\n        int b = 4;\n        System.out.print(\" \" + 7 + 2 + \" \");\n        System.out.print(a + b);\n        System.out.print(\" \" + a + b + \" \");\n        System.out.print(foo() + a + b + \" \");\n        System.out.println(a + b + foo());\n    }\n\n    String foo() \n    {\n        return \"foo\";\n    }\n}", "opta": "9 7 7 foo 7 7foo", "optb": "72 34 34 foo34 34foo", "optc": "9 7 7 foo34 34foo", "optd": "72 7 34 foo34 7foo", "ans": "D", "explanation": "Because all of these expressions use the + operator, there is no precedence to worry about and all of the expressions will be evaluated from left to right. If either operand being evaluated is a String, the + operator will concatenate the two operands; if both operands are numeric, the + operator will add the two operands."}, {"question": "What will be the output of the program?\nclass Test \n{\n    static int s;\n    public static void main(String [] args) \n    {\n        Test p = new Test();\n        p.start();\n        System.out.println(s);\n    }\n\n    void start() \n    {\n        int x = 7;\n        twice(x);\n        System.out.print(x + \" \");\n    }\n\n    void twice(int x) \n    {\n        x = x*2;\n        s = x;\n    }\n}", "opta": "7 7", "optb": "7 14", "optc": "14 0", "optd": "14 14", "ans": "B", "explanation": "The int x in the twice() method is not the same int x as in the start() method. Start()'s x is not affected by the twice() method. The instance variable s is updated by twice()'s x, which is 14."}, {"question": "What will be the output of the program?\nclass Two \n{\n    byte x;\n}\n\nclass PassO \n{\n    public static void main(String [] args) \n    {\n        PassO p = new PassO();\n        p.start();\n    }\n\n    void start() \n    {\n        Two t = new Two();\n        System.out.print(t.x + \" \");\n        Two t2 = fix(t);\n        System.out.println(t.x + \" \" + t2.x);\n    }\n\n    Two fix(Two tt) \n    {\n        tt.x = 42;\n        return tt;\n    }\n}", "opta": "null null 42", "optb": "0 0 42", "optc": "0 42 42", "optd": "0 0 0", "ans": "C", "explanation": "In the fix() method, the reference variable tt refers to the same object (class Two) as the t reference variable. Updating tt.x in the fix() method updates t.x (they are one in the same object). Remember also that the instance variable x in the Two class is initialized to 0."}, {"question": "What will be the output of the program?\nclass BoolArray \n{\n    boolean [] b = new boolean[3];\n    int count = 0;\n\n    void set(boolean [] x, int i) \n    {\n        x[i] = true;\n        ++count;\n    }\n\n    public static void main(String [] args) \n    {\n        BoolArray ba = new BoolArray();\n        ba.set(ba.b, 0);\n        ba.set(ba.b, 2);\n        ba.test();\n    }\n\n    void test() \n    {\n        if ( b[0] && b[1] | b[2] )\n            count++;\n        if ( b[1] && b[(++count - 2)] )\n            count += 7;\n        System.out.println(\"count = \" + count);\n    }\n}", "opta": "count = 0", "optb": "count = 2", "optc": "count = 3", "optd": "count = 4", "ans": "C", "explanation": "The reference variables b and x both refer to the same boolean array. count is incremented for each call to the set() method, and once again when the first if test is true. Because of the && short circuit operator, count is not incremented during the second if test."}, {"question": "What will be the output of the program?\npublic class Test \n{ \n    public static void leftshift(int i, int j) \n    {\n        i <<= j; \n    } \n    public static void main(String args[]) \n    {\n        int i = 4, j = 2; \n        leftshift(i, j); \n        System.out.printIn(i); \n    } \n}", "opta": "2", "optb": "4", "optc": "8", "optd": "16", "ans": "B", "explanation": "Java only ever passes arguments to a method by value (i.e. a copy of the variable) and never by reference. Therefore the value of the variable i remains unchanged in the main method.\nIf you are clever you will spot that 16 is 4 multiplied by 2 twice, (4 * 2 * 2) = 16. If you had 16 left shifted by three bits then 16 * 2 * 2 * 2 = 128. If you had 128 right shifted by 2 bits then 128 / 2 / 2 = 32. Keeping these points in mind, you don't have to go converting to binary to do the left and right bit shifts."}]]}