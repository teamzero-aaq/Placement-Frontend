{"test_questions": [[{"question": "What is the name of the method used to start a thread execution?", "opta": "init();", "optb": "start();", "optc": "run();", "optd": "resume();", "ans": "B", "explanation": "Option B is Correct. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread. \nOption A is wrong. There is no init() method in the Thread class.\nOption C is wrong. The run() method of a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption D is wrong. The resume() method is deprecated. It resumes a suspended thread."}, {"question": "Which two are valid constructors for Thread?\n\nThread(Runnable r, String name)\nThread()\nThread(int priority)\nThread(Runnable r, ThreadGroup g)\nThread(Runnable r, int priority)", "opta": "1 and 3", "optb": "2 and 4", "optc": "1 and 2", "optd": "2 and 5", "ans": "C", "explanation": "(1) and (2) are both valid constructors for Thread.\n(3), (4), and (5) are not legal Thread constructors, although (4) is close. If you reverse the arguments in (4), you'd have a valid constructor."}, {"question": "Which three are methods of the Object class?\n\nnotify();\nnotifyAll();\nisInterrupted();\nsynchronized();\ninterrupt();\nwait(long msecs);\nsleep(long msecs);\nyield();", "opta": "1, 2, 4", "optb": "2, 4, 5", "optc": "1, 2, 6", "optd": "2, 3, 4", "ans": "C", "explanation": "(1), (2), and (6) are correct. They are all related to the list of threads waiting on the specified object.\n(3), (5), (7), and (8) are incorrect answers. The methods isInterrupted() and interrupt() are instance methods of Thread. \nThe methods sleep() and yield() are static methods of Thread. \nD is incorrect because synchronized is a keyword and the synchronized() construct is part of the Java language."}, {"question": "class X implements Runnable \n{ \n    public static void main(String args[]) \n    {\n        /* Missing code? */\n    } \n    public void run() {} \n}\n\nWhich of the following line of code is suitable to start a thread ?", "opta": "Thread t = new Thread(X);", "optb": "Thread t = new Thread(X); t.start();", "optc": "X run = new X(); Thread t = new Thread(run); t.start();", "optd": "Thread t = new Thread(); x.run();", "ans": "C", "explanation": "Option C is suitable to start a thread."}, {"question": "Which cannot directly cause a thread to stop executing?", "opta": "Calling the SetPriority() method on a Thread object.", "optb": "Calling the wait() method on an object.", "optc": "Calling notify() method on an object.", "optd": "Calling read() method on an InputStream object.", "ans": "C", "explanation": "Option C is correct. notify() - wakes up a single thread that is waiting on this object's monitor."}, {"question": "Which two of the following methods are defined in class Thread?\n\nstart()\nwait()\nnotify()\nrun()\nterminate()", "opta": "1 and 4", "optb": "2 and 3", "optc": "3 and 4", "optd": "2 and 4", "ans": "A", "explanation": "(1) and (4). Only start() and run() are defined by the Thread class.\n(2) and (3) are incorrect because they are methods of the Object class. (5) is incorrect because there's no such method in any thread-related class."}, {"question": "Which three guarantee that a thread will leave the running state?\n\nyield()\nwait()\nnotify()\nnotifyAll()\nsleep(1000)\naLiveThread.join()\nThread.killThread()", "opta": "1, 2 and 4", "optb": "2, 5 and 6", "optc": "3, 4 and 7", "optd": "4, 5 and 7", "ans": "B", "explanation": "(2) is correct because wait() always causes the current thread to go into the object's wait pool. \n(5) is correct because sleep() will always pause the currently running thread for at least the duration specified in the sleep argument (unless an interrupted exception is thrown). \n(6) is correct because, assuming that the thread you're calling join() on is alive, the thread calling join() will immediately block until the thread you're calling join() on is no longer alive.\n(1) is wrong, but tempting. The yield() method is not guaranteed to cause a thread to leave the running state, although if there are runnable threads of the same priority as the currently running thread, then the current thread will probably leave the running state. \n(3) and (4) are incorrect because they don't cause the thread invoking them to leave the running state.\n(7) is wrong because there's no such method."}, {"question": "Which of the following will directly stop the execution of a Thread?", "opta": "wait()", "optb": "notify()", "optc": "notifyall()", "optd": "exits synchronized code", "ans": "A", "explanation": "Option A is correct. wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.\nOption B is wrong. notify() - wakes up a single thread that is waiting on this object's monitor. \nOption C is wrong. notifyAll() - wakes up all threads that are waiting on this object's monitor.\nOption D is wrong. Typically, releasing a lock means the thread holding the lock (in other words, the thread currently in the synchronized method) exits the synchronized method. At that point, the lock is free until some other thread enters a synchronized method on that object. Does entering/exiting synchronized code mean that the thread execution stops? Not necessarily because the thread can still run code that is not synchronized. I think the word directly in the question gives us a clue. Exiting synchronized code does not directly stop the execution of a thread."}, {"question": "Which method must be defined by a class implementing the java.lang.Runnable interface?", "opta": "void run()", "optb": "public void run()", "optc": "public void start()", "optd": "void run(int priority)", "ans": "B", "explanation": "Option B is correct because in an interface all methods are abstract by default therefore they must be overridden by the implementing class. The Runnable interface only contains 1 method, the void run() method therefore it must be implemented. \nOption A and D are incorrect because they are narrowing the access privileges i.e. package(default) access is narrower than public access. \nOption C is not method in the Runnable interface therefore it is incorrect."}, {"question": "Which will contain the body of the thread?", "opta": "run();", "optb": "start();", "optc": "stop();", "optd": "main();", "ans": "A", "explanation": "Option A is Correct. The run() method to a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption B is wrong. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread. \nOption C is wrong. The stop() method is deprecated. It forces the thread to stop executing. \nOption D is wrong. Is the main entry point for an application."}, {"question": "Which method registers a thread in a thread scheduler?", "opta": "run();", "optb": "construct();", "optc": "start();", "optd": "register();", "ans": "C", "explanation": "Option C is correct. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.\nOption A is wrong. The run() method of a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption B is wrong. There is no construct() method in the Thread class.\nOption D is wrong. There is no register() method in the Thread class."}, {"question": "Assume the following method is properly synchronized and called from a thread A on an object B:\nwait(2000);\nAfter calling this method, when will the thread A become a candidate to get another turn at the CPU?", "opta": "After thread A is notified, or after two seconds.", "optb": "After the lock on B is released, or after two seconds.", "optc": "Two seconds after thread A is notified.", "optd": "Two seconds after lock B is released.", "ans": "A", "explanation": "Option A. Either of the two events (notification or wait time expiration) will make the thread become a candidate for running again.\nOption B is incorrect because a waiting thread will not return to runnable when the lock is released, unless a notification occurs.\nOption C is incorrect because the thread will become a candidate immediately after notification, not two seconds afterwards. \nOption D is also incorrect because a thread will not come out of a waiting pool just because a lock has been released."}, {"question": "Which of the following will not directly cause a thread to stop?", "opta": "notify()", "optb": "wait()", "optc": "InputStream access", "optd": "sleep()", "ans": "A", "explanation": "Option A is correct. notify() - wakes up a single thread that is waiting on this object's monitor.\nOption B is wrong. wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nOption C is wrong. Methods of the InputStream class block until input data is available, the end of the stream is detected, or an exception is thrown. Blocking means that a thread may stop until certain conditions are met.\nOption D is wrong. sleep() - Causes the currently executing thread to sleep (temporarily cease execution) for a specified number of milliseconds. The thread does not lose ownership of any monitors."}, {"question": "Which class or interface defines the wait(), notify(),and notifyAll() methods?", "opta": "Object", "optb": "Thread", "optc": "Runnable", "optd": "Class", "ans": "A", "explanation": "The Object class defines these thread-specific methods.\nOption B, C, and D are incorrect because they do not define these methods. And yes, the Java API does define a class called Class, though you do not need to know it for the exam."}, {"question": "public class MyRunnable implements Runnable \n{\n    public void run() \n    {\n        // some code here\n    }\n}\n\nwhich of these will create and start this thread?", "opta": "new Runnable(MyRunnable).start();", "optb": "new Thread(MyRunnable).run();", "optc": "new Thread(new MyRunnable()).start();", "optd": "new MyRunnable().start();", "ans": "C", "explanation": "Because the class implements Runnable, an instance of it has to be passed to the Thread constructor, and then the instance of the Thread has to be started.\nA is incorrect. There is no constructor like this for Runnable because Runnable is an interface, and it is illegal to pass a class or interface name to any constructor.\nB is incorrect for the same reason; you can't pass a class or interface name to any constructor.\nD is incorrect because MyRunnable doesn't have a start() method, and the only start() method that can start a thread of execution is the start() in the Thread class."}]]}