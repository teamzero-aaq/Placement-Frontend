{"test_questions": [[{"question": "Which is true about an anonymous inner class?", "opta": "It can extend exactly one class and implement exactly one interface.", "optb": "It can extend exactly one class and can implement multiple interfaces.", "optc": "It can extend exactly one class or implement exactly one interface.", "optd": "It can implement multiple interfaces regardless of whether it also extends a class.", "ans": "C", "explanation": "Option C is correct because the syntax of an anonymous inner class allows for only one named type after the new, and that type must be either a single interface (in which case the anonymous class implements that one interface) or a single class (in which case the anonymous class extends that one class).\nOption A, B, D, and E are all incorrect because they don't follow the syntax rules described in the response for answer Option C."}, {"question": "class Boo \n{\n    Boo(String s) { }\n    Boo() { }\n}\nclass Bar extends Boo \n{\n    Bar() { }\n    Bar(String s) {super(s);}\n    void zoo() \n    {\n    // insert code here\n    }\n}\n\nwhich one create an anonymous inner class from within class Bar?", "opta": "Boo f = new Boo(24) { };", "optb": "Boo f = new Bar() { };", "optc": "Bar f = new Boo(String s) { };", "optd": "Boo f = new Boo.Bar(String s) { };", "ans": "B", "explanation": "Option B is correct because anonymous inner classes are no different from any other class when it comes to polymorphism. That means you are always allowed to declare a reference variable of the superclass type and have that reference variable refer to an instance of a subclass type, which in this case is an anonymous subclass of Bar. Since Bar is a subclass of Boo, it all works.\nOption A is incorrect because it passes an int to the Boo constructor, and there is no matching constructor in the Boo class.\nOption C is incorrect because it violates the rules of polymorphism\u2014you cannot refer to a superclass type using a reference variable declared as the subclass type. The superclass is not guaranteed to have everything the subclass has.\nOption D uses incorrect syntax."}, {"question": "Which is true about a method-local inner class?", "opta": "It must be marked final.", "optb": "It can be marked abstract.", "optc": "It can be marked public.", "optd": "It can be marked static.", "ans": "B", "explanation": "Option B is correct because a method-local inner class can be abstract, although it means a subclass of the inner class must be created if the abstract class is to be used (so an abstract method-local inner class is probably not useful).\nOption A is incorrect because a method-local inner class does not have to be declared final (although it is legal to do so).\nC and D are incorrect because a method-local inner class cannot be made public (remember-you cannot mark any local variables as public), or static."}, {"question": "Which statement is true about a static nested class?", "opta": "You must have a reference to an instance of the enclosing class in order to instantiate it.", "optb": "It does not have access to nonstatic members of the enclosing class.", "optc": "It's variables and methods must be static.", "optd": "It must extend the enclosing class.", "ans": "B", "explanation": "Option B is correct because a static nested class is not tied to an instance of the enclosing class, and thus can't access the nonstatic members of the class (just as a static method can't access nonstatic members of a class).\nOption A is incorrect because static nested classes do not need (and can't use) a reference to an instance of the enclosing class.\nOption C is incorrect because static nested classes can declare and define nonstatic members.\nOption D is wrong because it just is. There's no rule that says an inner or nested class has to extend anything."}, {"question": "Which constructs an anonymous inner class instance?", "opta": "Runnable r = new Runnable() { };", "optb": "Runnable r = new Runnable(public void run() { });", "optc": "Runnable r = new Runnable { public void run(){}};", "optd": "System.out.println(new Runnable() {public void run() { }});", "ans": "D", "explanation": "D is correct. It defines an anonymous inner class instance, which also means it creates an instance of that new anonymous class at the same time. The anonymous class is an implementer of the Runnable interface, so it must override the run() method of Runnable.\nA is incorrect because it doesn't override the run() method, so it violates the rules of interface implementation.\nB and C use incorrect syntax."}, {"question": "class Foo \n{\n    class Bar{ }\n}\nclass Test \n{\n    public static void main (String [] args) \n    {\n        Foo f = new Foo();\n        /* Line 10: Missing statement ? */\n    }\n}\n\nwhich statement, inserted at line 10, creates an instance of Bar?", "opta": "Foo.Bar b = new Foo.Bar();", "optb": "Foo.Bar b = f.new Bar();", "optc": "Bar b = new f.Bar();", "optd": "Bar b = f.new Bar();", "ans": "B", "explanation": "Option B is correct because the syntax is correct-using both names (the enclosing class and the inner class) in the reference declaration, then using a reference to the enclosing class to invoke new on the inner class.\nOption A, C and D all use incorrect syntax. A is incorrect because it doesn't use a reference to the enclosing class, and also because it includes both names in the new.\nC is incorrect because it doesn't use the enclosing class name in the reference variable declaration, and because the new syntax is wrong.\nD is incorrect because it doesn't use the enclosing class name in the reference variable declaration."}, {"question": "public class MyOuter \n{\n    public static class MyInner \n    {\n        public static void foo() { }\n    }\n}\n \nwhich statement, if placed in a class other than MyOuter or MyInner, instantiates an instance of the nested class?", "opta": "MyOuter.MyInner m = new MyOuter.MyInner();", "optb": "MyOuter.MyInner mi = new MyInner();", "optc": "MyOuter m = new MyOuter();MyOuter.MyInner mi = m.new MyOuter.MyInner();", "optd": "MyInner mi = new MyOuter.MyInner();", "ans": "A", "explanation": "MyInner is a static nested class, so it must be instantiated using the fully-scoped name of MyOuter.MyInner.\nOption B is incorrect because it doesn't use the enclosing name in the new.\nOption C is incorrect because it uses incorrect syntax. When you instantiate a nested class by invoking new on an instance of the enclosing class, you do not use the enclosing name. The difference between Option A and C is that Option C is calling new on an instance of the enclosing class rather than just new by itself. \nOption D is incorrect because it doesn't use the enclosing class name in the variable declaration."}]]}