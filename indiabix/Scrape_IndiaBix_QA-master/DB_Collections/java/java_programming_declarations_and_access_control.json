{"test_questions": [[{"question": "You want subclasses in any package to have access to members of a superclass. Which is the most restrictive access that accomplishes this objective?", "opta": "public", "optb": "private", "optc": "protected", "optd": "transient", "ans": "C", "explanation": "Access modifiers dictate which classes, not which instances, may access features. \nMethods and variables are collectively known as members. Method and variable members are given access control in exactly the same way. \nprivate makes a member accessible only from within its own class \nprotected makes a member accessible only to classes in the same package or subclass of the class \ndefault access is very similar to protected (make sure you spot the difference) default access makes a member accessible only to classes in the same package.\npublic means that all other classes regardless of the package that they belong to, can access the member (assuming the class itself is visible) \nfinal makes it impossible to extend a class, when applied to a method it prevents a method from being overridden in a subclass, when applied to a variable it makes it impossible to reinitialise a variable once it has been initialised\nabstract declares a method that has not been implemented.\ntransient indicates that a variable is not part of the persistent state of an object.\nvolatile indicates that a thread must reconcile its working copy of the field with the master copy every time it accesses the variable.\nAfter examining the above it should be obvious that the access modifier that provides the most restrictions for methods to be accessed from the subclasses of the class from another package is C - protected. A is also a contender but C is more restrictive, B would be the answer if the constraint was the \"same package\" instead of \"any package\" in other words the subclasses clause in the question eliminates default."}, {"question": "public class Outer \n{ \n    public void someOuterMethod() \n    {\n        //Line 5 \n    } \n    public class Inner { } \n    \n    public static void main(String[] argv) \n    {\n        Outer ot = new Outer(); \n        //Line 10\n    } \n} \n\nWhich of the following code fragments inserted, will allow to compile?", "opta": "new Inner(); //At line 5", "optb": "new Inner(); //At line 10", "optc": "new ot.Inner(); //At line 10", "optd": "new Outer.Inner(); //At line 10", "ans": "A", "explanation": "Option A compiles without problem.\nOption B gives error - non-static variable cannot be referenced from a static context.\nOption C package ot does not exist.\nOption D gives error - non-static variable cannot be referenced from a static context."}, {"question": "interface Base \n{\n    boolean m1 ();\n    byte m2(short s);\n}\n\nwhich two code fragments will compile?\n\ninterface Base2 implements Base {}\n\nabstract class Class2 extends Base \n{ public boolean m1(){ return true; }}\n\nabstract class Class2 implements Base {}\nabstract class Class2 implements Base  \n{ public boolean m1(){ return (7 > 4); }}\nabstract class Class2 implements Base \n{ protected boolean m1(){ return (5 > 7) }}", "opta": "1 and 2", "optb": "2 and 3", "optc": "3 and 4", "optd": "1 and 5", "ans": "C", "explanation": "(3) is correct because an abstract class doesn't have to implement any or all of its interface's methods. (4) is correct because the method is correctly implemented ((7 > 4) is a boolean).\n(1) is incorrect because interfaces don't implement anything. (2) is incorrect because classes don't extend interfaces. (5) is incorrect because interface methods are implicitly public, so the methods being implemented must be public."}, {"question": "Which three form part of correct array declarations?\n\npublic int a [ ]\nstatic int [ ] a\npublic [ ] int a\nprivate int a [3]\nprivate int [3] a [ ]\npublic final int [ ] a", "opta": "1, 3, 4", "optb": "2, 4, 5", "optc": "1, 2, 6", "optd": "2, 5, 6", "ans": "C", "explanation": "(1), (2) and (6) are valid array declarations.\nOption (3) is not a correct array declaration. The compiler complains with: illegal start of type. The brackets are in the wrong place. The following would work: public int[ ] a\nOption (4) is not a correct array declaration. The compiler complains with: ']' expected. A closing bracket is expected in place of the 3. The following works: private int a []\nOption (5) is not a correct array declaration. The compiler complains with 2 errors:\n']' expected. A closing bracket is expected in place of the 3 and \n<identifier> expected A variable name is expected after a[ ] ."}, {"question": "public class Test { }\n\nWhat is the prototype of the default constructor?", "opta": "Test( )", "optb": "Test(void)", "optc": "public Test( )", "optd": "public Test(void)", "ans": "C", "explanation": "Option A and B are wrong because they use the default access modifier and the access modifier for the class is public (remember, the default constructor has the same access modifier as the class).\nOption D is wrong. The void makes the compiler think that this is a method specification - in fact if it were a method specification the compiler would spit it out."}, {"question": "What is the most restrictive access modifier that will allow members of one class to have access to members of another class in the same package?", "opta": "public", "optb": "abstract", "optc": "protected", "optd": "synchronized", "opte": "default access", "ans": "E", "explanation": "default access is the \"package oriented\" access modifier.\nOption A and C are wrong because public and protected are less restrictive. Option B and D are wrong because abstract and synchronized are not access modifiers."}, {"question": "Which of the following is/are legal method declarations?\n\nprotected abstract void m1();\nstatic final void m1(){}\nsynchronized public final void m1() {}\nprivate native void m1();", "opta": "1 and 3", "optb": "2 and 4", "optc": "1 only", "optd": "All of them are legal declarations.", "ans": "D", "explanation": "All the given statements are legal declarations."}, {"question": "Which cause a compiler error?", "opta": "int[ ] scores = {3, 5, 7};", "optb": "int [ ][ ] scores = {2,7,6}, {9,3,45};", "optc": "String cats[ ] = {\"Fluffy\", \"Spot\", \"Zeus\"};", "optd": "boolean results[ ] = new boolean [] {true, false, true};", "opte": "Integer results[ ] = {new Integer(3), new Integer(5), new Integer(8)};", "ans": "B", "explanation": "Option B generates a compiler error: <identifier> expected. The compiler thinks you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create one 3 x 3 two-dimensional array.\nTo correct the problem and make option B compile you need to add an extra pair of curly brackets:\nint [ ] [ ] scores = { {2,7,6}, {9,3,45} };"}, {"question": "Which three are valid method signatures in an interface?\n\nprivate int getArea();\npublic float getVol(float x);\npublic void main(String [] args);\npublic static void main(String [] args);\nboolean setFlag(Boolean [] test);", "opta": "1 and 2", "optb": "2, 3 and 5", "optc": "3, 4, and 5", "optd": "2 and 4", "ans": "B", "explanation": "(2), (3), and (5). These are all valid interface method signatures.\n(1), is incorrect because an interface method must be public; if it is not explicitly declared public it will be made public implicitly. (4) is incorrect because interface methods cannot be static."}, {"question": "You want a class to have access to members of another class in the same package. Which is the most restrictive access that accomplishes this objective?", "opta": "public", "optb": "private", "optc": "protected", "optd": "default access", "ans": "D", "explanation": "The only two real contenders are C and D. Protected access Option C makes a member accessible only to classes in the same package or subclass of the class. While default access Option D makes a member accessible only to classes in the same package."}, {"question": "What is the widest valid returnType for methodA in line 3? \npublic class ReturnIt \n{ \n    returnType methodA(byte x, double y) /* Line 3 */\n    { \n        return (long)x / y * 2; \n    } \n}", "opta": "int", "optb": "byte", "optc": "long", "optd": "double", "ans": "D", "explanation": "However A, B and C are all wrong. Each of these would result in a narrowing conversion. Whereas we want a widening conversion, therefore the only correct answer is D. Don't be put off by the long cast, this applies only to the variable x and not the rest of the expression. It is the variable y (of type double) that forces the widening conversion to double.\nJava's widening conversions are:\n- From a byte to a short, an int, a long, a float, or a double.\n- From a short, an int, a long, a float, or a double.\n- From a char to an int, a long, a float, or a double.\n- From an int to a long, a float, or a double.\n- From a long to a float, or a double.\n- From a float to a double."}, {"question": "class A \n{  \n    protected int method1(int a, int b) \n    {\n        return 0; \n    } \n}\n\nWhich is valid in a class that extends class A?", "opta": "public int method1(int a, int b) {return 0; }", "optb": "private int method1(int a, int b) { return 0; }", "optc": "public short method1(int a, int b) { return 0; }", "optd": "static protected int method1(int a, int b) { return 0; }", "ans": "A", "explanation": "Option A is correct - because the class that extends A is just simply overriding method1.\nOption B is wrong - because it can't override as there are less access privileges in the subclass method1. \nOption C is wrong - because to override it, the return type needs to be an integer. The different return type means that the method is not overriding but the same argument list means that the method is not overloading. Conflict - compile time error. \nOption D is wrong - because you can't override a method and make it a class method i.e. using static."}, {"question": "Which one creates an instance of an array?", "opta": "int[ ] ia = new int[15];", "optb": "float fa = new float[20];", "optc": "char[ ] ca = \"Some String\";", "optd": "int ia[ ] [ ] = { 4, 5, 6 }, { 1,2,3 };", "ans": "A", "explanation": "Option A is correct. It uses correct array declaration and correct array construction.\nOption B is incorrect. It generates a compiler error: incompatible types because the array variable declaration is not correct. The array construction expects a reference type, but it is supplied with a primitive type in the declaration.\nOption C is incorrect. It generates a compiler error: incompatible types because a string literal is not assignable to a character type variable. \nOption D is wrong, it generates a compiler error <identifier> expected. The compiler thinks that you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create a 3 x 3 two-dimensional array."}, {"question": "Which two of the following are legal declarations for nonnested classes and interfaces?\n\nfinal abstract class Test {}\npublic static interface Test {}\nfinal public class Test {}\nprotected abstract class Test {}\nprotected interface Test {}\nabstract public class Test {}", "opta": "1 and 4", "optb": "2 and 5", "optc": "3 and 6", "optd": "4 and 6", "ans": "C", "explanation": "(3), (6). Both are legal class declarations.\n(1) is wrong because a class cannot be abstract and final\u2014there would be no way to use such a class. (2) is wrong because interfaces and classes cannot be marked as static. (4) and (5) are wrong because classes and interfaces cannot be marked as protected."}, {"question": "Which of the following class level (nonlocal) variable declarations will not compile?", "opta": "protected int a;", "optb": "transient int b = 3;", "optc": "private synchronized int e;", "optd": "volatile int d;", "ans": "C", "explanation": "Option C will not compile; the synchronized modifier applies only to methods.\nOption A and B will compile because protected and transient are legal variable modifiers. Option D will compile because volatile is a proper variable modifier."}, {"question": "Which two cause a compiler error?\n\nfloat[ ] f = new float(3);\nfloat f2[ ] = new float[ ];\nfloat[ ]f1 = new float[3];\nfloat f3[ ] = new float[3];\nfloat f5[ ] = {1.0f, 2.0f, 2.0f};", "opta": "2, 4", "optb": "3, 5", "optc": "4, 5", "optd": "1, 2", "ans": "D", "explanation": "(1) causes two compiler errors ( '[' expected and illegal start of expression) because the wrong type of bracket is used, ( ) instead of [ ]. The following is  the correct syntax: float[ ] f = new float[3];\n(2) causes a compiler error ( '{' expected ) because the array constructor does not specify the number of elements in the array. The following is the correct syntax: float f2[ ] = new float[3]; \n(3), (4), and (5) compile without error."}, {"question": "Given a method in a protected class, what access modifier do you use to restrict access to that method to only the other members of the same class?", "opta": "final", "optb": "static", "optc": "private", "optd": "protected", "opte": "volatile", "ans": "C", "explanation": "The private access modifier limits access to members of the same class.\nOption A, B, D, and E are wrong because protected are the wrong access modifiers, and final, static, and volatile are modifiers but not access modifiers."}, {"question": "Which is a valid declaration within an interface?", "opta": "public static short stop = 23;", "optb": "protected short stop = 23;", "optc": "transient short stop = 23;", "optd": "final void madness(short stop);", "ans": "A", "explanation": "(A) is valid interface declarations.\n(B) and (C) are incorrect because interface variables cannot be either protected or transient. (D) is incorrect because interface methods cannot be final or static."}]]}