{"test_questions": [[{"question": "void start() {  \n    A a = new A(); \n    B b = new B(); \n    a.s(b);  \n    b = null; /* Line 5 */\n    a = null;  /* Line 6 */\n    System.out.println(\"start completed\"); /* Line 7 */\n} \n\nWhen is the B object, created in line 3, eligible for garbage collection?", "opta": "after line 5", "optb": "after line 6", "optc": "after line 7", "optd": "There is no way to be absolutely certain.", "ans": "D", "explanation": "No answer description available for this question. Let us discuss."}, {"question": "class HappyGarbage01 \n{ \n    public static void main(String args[]) \n    {\n        HappyGarbage01 h = new HappyGarbage01(); \n        h.methodA(); /* Line 6 */\n    } \n    Object methodA() \n    {\n        Object obj1 = new Object(); \n        Object [] obj2 = new Object[1]; \n        obj2[0] = obj1; \n        obj1 = null; \n        return obj2[0]; \n    } \n}\n\nWhere will be the most chance of the garbage collector being invoked?", "opta": "After line 9", "optb": "After line 10", "optc": "After line 11", "optd": "Garbage collector never invoked in methodA()", "ans": "D", "explanation": "Option D is correct. Garbage collection takes place after the method has returned its reference to the object. The method returns to line 6, there is no reference to store the return value. so garbage collection takes place after line 6. \nOption A is wrong. Because the reference to obj1 is stored in obj2[0]. The Object obj1 still exists on the heap and can be accessed by an active thread through the reference stored in obj2[0]. \nOption B is wrong. Because it is only one of the references to the object obj1, the other reference is maintained in obj2[0]. \nOption C is wrong. The garbage collector will not be called here because a reference to the object is being maintained and returned in obj2[0]."}, {"question": "class Bar { } \nclass Test \n{  \n    Bar doBar() \n    {\n        Bar b = new Bar(); /* Line 6 */\n        return b; /* Line 7 */\n    } \n    public static void main (String args[]) \n    { \n        Test t = new Test();  /* Line 11 */\n        Bar newBar = t.doBar();  /* Line 12 */\n        System.out.println(\"newBar\"); \n        newBar = new Bar(); /* Line 14 */\n        System.out.println(\"finishing\"); /* Line 15 */\n    } \n}\n\nAt what point is the Bar object, created on line 6, eligible for garbage collection?", "opta": "after line 12", "optb": "after line 14", "optc": "after line 7, when doBar() completes", "optd": "after line 15, when main() completes", "ans": "B", "explanation": "Option B is correct. All references to the Bar object created on line 6 are destroyed when a new reference to a new Bar object is assigned to the variable newBar on line 14. Therefore the Bar object, created on line 6, is eligible for garbage collection after line 14. \nOption A is wrong. This actually protects the object from garbage collection.\nOption C is wrong. Because the reference in the doBar() method is returned on line 7 and is stored in newBar on line 12. This preserver the object created on line 6. \nOption D is wrong. Not applicable because the object is eligible for garbage collection after line 14."}, {"question": "class Test \n{  \n    private Demo d; \n    void start() \n    {  \n        d = new Demo(); \n        this.takeDemo(d); /* Line 7 */\n    } /* Line 8 */\n    void takeDemo(Demo demo) \n    { \n        demo = null;  \n        demo = new Demo(); \n    } \n}\n\nWhen is the Demo object eligible for garbage collection?", "opta": "After line 7", "optb": "After line 8", "optc": "After the start() method completes", "optd": "When the instance running this code is made eligible for garbage collection.", "ans": "D", "explanation": "Option D is correct. By a process of elimination.\nOption A is wrong. The variable d is a member of the Test class and is never directly set to null. \nOption B is wrong. A copy of the variable d is set to null and not the actual variable d. \nOption C is wrong. The variable d exists outside the start() method (it is a class member). So, when the start() method finishes the variable d still holds a reference."}, {"question": "public class X \n{\n    public static void main(String [] args) \n    {\n        X x = new X();\n        X x2 = m1(x); /* Line 6 */\n        X x4 = new X();\n        x2 = x4; /* Line 8 */\n        doComplexStuff();\n    }\n    static X m1(X mx) \n    {\n        mx = new X();\n        return mx;\n    }\n}\n\nAfter line 8 runs. how many objects are eligible for garbage collection?", "opta": "0", "optb": "1", "optc": "2", "optd": "3", "ans": "B", "explanation": "By the time line 8 has run, the only object without a reference is the one generated as a result of line 6. Remember that \"Java is pass by value,\" so the reference variable x is not affected by the m1() method.\nRef: http://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html"}, {"question": "public Object m() \n{  \n    Object o = new Float(3.14F); \n    Object [] oa = new Object[l];\n    oa[0] = o; /* Line 5 */\n    o = null;  /* Line 6 */\n    oa[0] = null; /* Line 7 */\n    return o; /* Line 8 */\n}\n\nWhen is the Float object, created in line 3, eligible for garbage collection?", "opta": "just after line 5", "optb": "just after line 6", "optc": "just after line 7", "optd": "just after line 8", "ans": "C", "explanation": "Option A is wrong. This simply copies the object reference into the array.\nOption B is wrong. The reference o is set to null, but, oa[0] still maintains the reference to the Float object.\nOption C is correct. The thread of execution will then not have access to the object."}, {"question": "class X2 \r\n{\r\n    public X2 x;\r\n    public static void main(String [] args) \r\n    {\r\n        X2 x2 = new X2();  /* Line 6 */\r\n        X2 x3 = new X2();  /* Line 7 */\r\n        x2.x = x3;\r\n        x3.x = x2;\r\n        x2 = new X2();\r\n        x3 = x2; /* Line 11 */\r\n        doComplexStuff();\r\n    }\r\n}\r\n\r\nafter line 11 runs, how many objects are eligible for garbage collection?", "opta": "0", "optb": "1", "optc": "2", "optd": "3", "ans": "C", "explanation": "This is an example of the islands of isolated objects. By the time line 11 has run, the objects instantiated in lines 6 and 7 are referring to each other, but no live thread can reach either of them."}, {"question": "What allows the programmer to destroy an object x?", "opta": "x.delete()", "optb": "x.finalize()", "optc": "Runtime.getRuntime().gc()", "optd": "Only the garbage collection system can destroy an object.", "ans": "D", "explanation": "Option D is correct. When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded. \nOption A is wrong. I found 4 delete() methods in all of the Java class structure. They are:\n\n\ndelete() - Method in class java.io.File : Deletes the file or directory denoted by this abstract pathname.\ndelete(int, int) - Method in class java.lang.StringBuffer : Removes the characters in a substring of this StringBuffer.\ndelete(int, int) - Method in interface javax.accessibility.AccessibleEditableText : Deletes the text between two indices\ndelete(int, int) - Method in class : javax.swing.text.JTextComponent.AccessibleJTextComponent; Deletes the text between two indices\n\n\nNone of these destroy the object to which they belong. \nOption B is wrong. I found 19 finalize() methods. The most interesting, from this questions point of view, was the finalize() method in class java.lang.Object which is called by the garbage collector on an object when garbage collection determines that there are no more references to the object. This method does not destroy the object to which it belongs. \nOption C is wrong. But it is interesting. The Runtime class has many methods, two of which are: \n\n\ngetRuntime() - Returns the runtime object associated with the current Java application.\ngc() - Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects. Interesting as this is, it doesn't destroy the object."}]]}