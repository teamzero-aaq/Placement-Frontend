{"test_questions": [[{"question": "What will be the output of the program?\npublic class Test \n{  \n    public static void main(String[] args) \n    { \n        int x = 0;  \n        assert (x > 0) ? \"assertion failed\" : \"assertion passed\" ; \n        System.out.println(\"finished\");  \n    } \n}", "opta": "finished", "optb": "Compiliation fails.", "optc": "An AssertionError is thrown and finished is output.", "optd": "An AssertionError is thrown with the message \"assertion failed.\"", "ans": "B", "explanation": "Compilation Fails. You can't use the Assert statement in a similar way to the ternary operator. Don't confuse."}, {"question": "public class Test \n{ \n    public void foo() \n    {\n        assert false; /* Line 5 */\n        assert false; /* Line 6 */\n    } \n    public void bar()\n    {\n        while(true)\n        {\n            assert false; /* Line 12 */\n        } \n        assert false;  /* Line 14 */\n    } \n}\nWhat causes compilation to fail?", "opta": "Line 5", "optb": "Line 6", "optc": "Line 12", "optd": "Line 14", "ans": "D", "explanation": "Option D is correct. Compilation fails because of an unreachable statement at line 14. It is a compile-time error if a statement cannot be executed because it is unreachable. The question is now, why is line 20 unreachable? If it is because of the assert then surely line 6 would also be unreachable. The answer must be something other than assert. \nExamine the following: \nA while statement can complete normally if and only if at least one of the following is true: \n- The while statement is reachable and the condition expression is not a constant expression with value true.\n-There is a reachable break statement that exits the while statement. \nThe while statement at line 11 is infinite and there is no break statement therefore line 14 is unreachable. You can test this with the following code:\npublic class Test80 \n{ \n    public void foo() \n    {\n        assert false; \n        assert false; \n    } \n    public void bar()\n    {\n        while(true)\n        {\n            assert false; \n            break; \n        } \n        assert false;  \n    } \n}"}, {"question": "What will be the output of the program?\npublic class Test \n{\n    public static int y;\n    public static void foo(int x) \n    {\n        System.out.print(\"foo \");\n        y = x;\n    }\n    public static int bar(int z) \n    {\n        System.out.print(\"bar \");\n        return y = z;\n    }\n    public static void main(String [] args ) \n    {\n        int t = 0;\n        assert t > 0 : bar(7);\n        assert t > 1 : foo(8); /* Line 18 */\n        System.out.println(\"done \");\n    }\n}", "opta": "bar", "optb": "bar done", "optc": "foo done", "optd": "Compilation fails", "ans": "D", "explanation": "The foo() method returns void. It is a perfectly acceptable method, but because it returns void it cannot be used in an assert statement, so line 18 will not compile."}, {"question": "What will be the output of the program (when you run with the -ea option) ?\npublic class Test \n{  \n    public static void main(String[] args) \n    {\n        int x = 0;  \n        assert (x > 0) : \"assertion failed\"; /* Line 6 */\n        System.out.println(\"finished\"); \n    } \n}", "opta": "finished", "optb": "Compilation fails.", "optc": "An AssertionError is thrown.", "optd": "An AssertionError is thrown and finished is output.", "ans": "C", "explanation": "An assertion Error is thrown as normal giving the output \"assertion failed\". The word \"finished\" is not printed (ensure you run with the -ea option)\nAssertion failures are generally labeled in the stack trace with the file and line number from which they were thrown, and also in this case with the error's detail message  \"assertion failed\". The detail message is supplied by the assert statement in line 6."}, {"question": "public class Test2 \n{\n    public static int x;\n    public static int foo(int y) \n    {\n        return y * 2;\n    }\n    public static void main(String [] args) \n    {\n        int z = 5;\n        assert z > 0; /* Line 11 */\n        assert z > 2: foo(z); /* Line 12 */\n        if ( z < 7 )\n            assert z > 4; /* Line 14 */\n\n        switch (z) \n        {\n            case 4: System.out.println(\"4 \");\n            case 5: System.out.println(\"5 \");\n            default: assert z < 10;\n        }\n\n        if ( z < 10 )\n            assert z > 4: z++; /* Line 22 */\n        System.out.println(z);\n    }\n}\n\nwhich line is an example of an inappropriate use of assertions?", "opta": "Line 11", "optb": "Line 12", "optc": "Line 14", "optd": "Line 22", "ans": "D", "explanation": "Assert statements should not cause side effects. Line 22 changes the value of z if the assert statement is false.\nOption A is fine; a second expression in an assert statement is not required. \nOption B is fine because it is perfectly acceptable to call a method with the second expression of an assert statement. \nOption C is fine because it is proper to call an assert statement conditionally."}, {"question": "You want subclasses in any package to have access to members of a superclass. Which is the most restrictive access that accomplishes this objective?", "opta": "public", "optb": "private", "optc": "protected", "optd": "transient", "ans": "C", "explanation": "Access modifiers dictate which classes, not which instances, may access features. \nMethods and variables are collectively known as members. Method and variable members are given access control in exactly the same way. \nprivate makes a member accessible only from within its own class \nprotected makes a member accessible only to classes in the same package or subclass of the class \ndefault access is very similar to protected (make sure you spot the difference) default access makes a member accessible only to classes in the same package.\npublic means that all other classes regardless of the package that they belong to, can access the member (assuming the class itself is visible) \nfinal makes it impossible to extend a class, when applied to a method it prevents a method from being overridden in a subclass, when applied to a variable it makes it impossible to reinitialise a variable once it has been initialised\nabstract declares a method that has not been implemented.\ntransient indicates that a variable is not part of the persistent state of an object.\nvolatile indicates that a thread must reconcile its working copy of the field with the master copy every time it accesses the variable.\nAfter examining the above it should be obvious that the access modifier that provides the most restrictions for methods to be accessed from the subclasses of the class from another package is C - protected. A is also a contender but C is more restrictive, B would be the answer if the constraint was the \"same package\" instead of \"any package\" in other words the subclasses clause in the question eliminates default."}, {"question": "public class Outer \n{ \n    public void someOuterMethod() \n    {\n        //Line 5 \n    } \n    public class Inner { } \n    \n    public static void main(String[] argv) \n    {\n        Outer ot = new Outer(); \n        //Line 10\n    } \n} \n\nWhich of the following code fragments inserted, will allow to compile?", "opta": "new Inner(); //At line 5", "optb": "new Inner(); //At line 10", "optc": "new ot.Inner(); //At line 10", "optd": "new Outer.Inner(); //At line 10", "ans": "A", "explanation": "Option A compiles without problem.\nOption B gives error - non-static variable cannot be referenced from a static context.\nOption C package ot does not exist.\nOption D gives error - non-static variable cannot be referenced from a static context."}, {"question": "interface Base \n{\n    boolean m1 ();\n    byte m2(short s);\n}\n\nwhich two code fragments will compile?\n\ninterface Base2 implements Base {}\n\nabstract class Class2 extends Base \n{ public boolean m1(){ return true; }}\n\nabstract class Class2 implements Base {}\nabstract class Class2 implements Base  \n{ public boolean m1(){ return (7 > 4); }}\nabstract class Class2 implements Base \n{ protected boolean m1(){ return (5 > 7) }}", "opta": "1 and 2", "optb": "2 and 3", "optc": "3 and 4", "optd": "1 and 5", "ans": "C", "explanation": "(3) is correct because an abstract class doesn't have to implement any or all of its interface's methods. (4) is correct because the method is correctly implemented ((7 > 4) is a boolean).\n(1) is incorrect because interfaces don't implement anything. (2) is incorrect because classes don't extend interfaces. (5) is incorrect because interface methods are implicitly public, so the methods being implemented must be public."}, {"question": "Which three form part of correct array declarations?\n\npublic int a [ ]\nstatic int [ ] a\npublic [ ] int a\nprivate int a [3]\nprivate int [3] a [ ]\npublic final int [ ] a", "opta": "1, 3, 4", "optb": "2, 4, 5", "optc": "1, 2, 6", "optd": "2, 5, 6", "ans": "C", "explanation": "(1), (2) and (6) are valid array declarations.\nOption (3) is not a correct array declaration. The compiler complains with: illegal start of type. The brackets are in the wrong place. The following would work: public int[ ] a\nOption (4) is not a correct array declaration. The compiler complains with: ']' expected. A closing bracket is expected in place of the 3. The following works: private int a []\nOption (5) is not a correct array declaration. The compiler complains with 2 errors:\n']' expected. A closing bracket is expected in place of the 3 and \n<identifier> expected A variable name is expected after a[ ] ."}, {"question": "public class Test { }\n\nWhat is the prototype of the default constructor?", "opta": "Test( )", "optb": "Test(void)", "optc": "public Test( )", "optd": "public Test(void)", "ans": "C", "explanation": "Option A and B are wrong because they use the default access modifier and the access modifier for the class is public (remember, the default constructor has the same access modifier as the class).\nOption D is wrong. The void makes the compiler think that this is a method specification - in fact if it were a method specification the compiler would spit it out."}, {"question": "What is the most restrictive access modifier that will allow members of one class to have access to members of another class in the same package?", "opta": "public", "optb": "abstract", "optc": "protected", "optd": "synchronized", "opte": "default access", "ans": "E", "explanation": "default access is the \"package oriented\" access modifier.\nOption A and C are wrong because public and protected are less restrictive. Option B and D are wrong because abstract and synchronized are not access modifiers."}, {"question": "Which of the following is/are legal method declarations?\n\nprotected abstract void m1();\nstatic final void m1(){}\nsynchronized public final void m1() {}\nprivate native void m1();", "opta": "1 and 3", "optb": "2 and 4", "optc": "1 only", "optd": "All of them are legal declarations.", "ans": "D", "explanation": "All the given statements are legal declarations."}, {"question": "Which cause a compiler error?", "opta": "int[ ] scores = {3, 5, 7};", "optb": "int [ ][ ] scores = {2,7,6}, {9,3,45};", "optc": "String cats[ ] = {\"Fluffy\", \"Spot\", \"Zeus\"};", "optd": "boolean results[ ] = new boolean [] {true, false, true};", "opte": "Integer results[ ] = {new Integer(3), new Integer(5), new Integer(8)};", "ans": "B", "explanation": "Option B generates a compiler error: <identifier> expected. The compiler thinks you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create one 3 x 3 two-dimensional array.\nTo correct the problem and make option B compile you need to add an extra pair of curly brackets:\nint [ ] [ ] scores = { {2,7,6}, {9,3,45} };"}, {"question": "Which three are valid method signatures in an interface?\n\nprivate int getArea();\npublic float getVol(float x);\npublic void main(String [] args);\npublic static void main(String [] args);\nboolean setFlag(Boolean [] test);", "opta": "1 and 2", "optb": "2, 3 and 5", "optc": "3, 4, and 5", "optd": "2 and 4", "ans": "B", "explanation": "(2), (3), and (5). These are all valid interface method signatures.\n(1), is incorrect because an interface method must be public; if it is not explicitly declared public it will be made public implicitly. (4) is incorrect because interface methods cannot be static."}, {"question": "You want a class to have access to members of another class in the same package. Which is the most restrictive access that accomplishes this objective?", "opta": "public", "optb": "private", "optc": "protected", "optd": "default access", "ans": "D", "explanation": "The only two real contenders are C and D. Protected access Option C makes a member accessible only to classes in the same package or subclass of the class. While default access Option D makes a member accessible only to classes in the same package."}, {"question": "What is the widest valid returnType for methodA in line 3? \npublic class ReturnIt \n{ \n    returnType methodA(byte x, double y) /* Line 3 */\n    { \n        return (long)x / y * 2; \n    } \n}", "opta": "int", "optb": "byte", "optc": "long", "optd": "double", "ans": "D", "explanation": "However A, B and C are all wrong. Each of these would result in a narrowing conversion. Whereas we want a widening conversion, therefore the only correct answer is D. Don't be put off by the long cast, this applies only to the variable x and not the rest of the expression. It is the variable y (of type double) that forces the widening conversion to double.\nJava's widening conversions are:\n- From a byte to a short, an int, a long, a float, or a double.\n- From a short, an int, a long, a float, or a double.\n- From a char to an int, a long, a float, or a double.\n- From an int to a long, a float, or a double.\n- From a long to a float, or a double.\n- From a float to a double."}, {"question": "class A \n{  \n    protected int method1(int a, int b) \n    {\n        return 0; \n    } \n}\n\nWhich is valid in a class that extends class A?", "opta": "public int method1(int a, int b) {return 0; }", "optb": "private int method1(int a, int b) { return 0; }", "optc": "public short method1(int a, int b) { return 0; }", "optd": "static protected int method1(int a, int b) { return 0; }", "ans": "A", "explanation": "Option A is correct - because the class that extends A is just simply overriding method1.\nOption B is wrong - because it can't override as there are less access privileges in the subclass method1. \nOption C is wrong - because to override it, the return type needs to be an integer. The different return type means that the method is not overriding but the same argument list means that the method is not overloading. Conflict - compile time error. \nOption D is wrong - because you can't override a method and make it a class method i.e. using static."}, {"question": "Which one creates an instance of an array?", "opta": "int[ ] ia = new int[15];", "optb": "float fa = new float[20];", "optc": "char[ ] ca = \"Some String\";", "optd": "int ia[ ] [ ] = { 4, 5, 6 }, { 1,2,3 };", "ans": "A", "explanation": "Option A is correct. It uses correct array declaration and correct array construction.\nOption B is incorrect. It generates a compiler error: incompatible types because the array variable declaration is not correct. The array construction expects a reference type, but it is supplied with a primitive type in the declaration.\nOption C is incorrect. It generates a compiler error: incompatible types because a string literal is not assignable to a character type variable. \nOption D is wrong, it generates a compiler error <identifier> expected. The compiler thinks that you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create a 3 x 3 two-dimensional array."}, {"question": "Which two of the following are legal declarations for nonnested classes and interfaces?\n\nfinal abstract class Test {}\npublic static interface Test {}\nfinal public class Test {}\nprotected abstract class Test {}\nprotected interface Test {}\nabstract public class Test {}", "opta": "1 and 4", "optb": "2 and 5", "optc": "3 and 6", "optd": "4 and 6", "ans": "C", "explanation": "(3), (6). Both are legal class declarations.\n(1) is wrong because a class cannot be abstract and final\u2014there would be no way to use such a class. (2) is wrong because interfaces and classes cannot be marked as static. (4) and (5) are wrong because classes and interfaces cannot be marked as protected."}, {"question": "Which of the following class level (nonlocal) variable declarations will not compile?", "opta": "protected int a;", "optb": "transient int b = 3;", "optc": "private synchronized int e;", "optd": "volatile int d;", "ans": "C", "explanation": "Option C will not compile; the synchronized modifier applies only to methods.\nOption A and B will compile because protected and transient are legal variable modifiers. Option D will compile because volatile is a proper variable modifier."}, {"question": "Which two cause a compiler error?\n\nfloat[ ] f = new float(3);\nfloat f2[ ] = new float[ ];\nfloat[ ]f1 = new float[3];\nfloat f3[ ] = new float[3];\nfloat f5[ ] = {1.0f, 2.0f, 2.0f};", "opta": "2, 4", "optb": "3, 5", "optc": "4, 5", "optd": "1, 2", "ans": "D", "explanation": "(1) causes two compiler errors ( '[' expected and illegal start of expression) because the wrong type of bracket is used, ( ) instead of [ ]. The following is  the correct syntax: float[ ] f = new float[3];\n(2) causes a compiler error ( '{' expected ) because the array constructor does not specify the number of elements in the array. The following is the correct syntax: float f2[ ] = new float[3]; \n(3), (4), and (5) compile without error."}, {"question": "Given a method in a protected class, what access modifier do you use to restrict access to that method to only the other members of the same class?", "opta": "final", "optb": "static", "optc": "private", "optd": "protected", "opte": "volatile", "ans": "C", "explanation": "The private access modifier limits access to members of the same class.\nOption A, B, D, and E are wrong because protected are the wrong access modifiers, and final, static, and volatile are modifiers but not access modifiers."}, {"question": "Which is a valid declaration within an interface?", "opta": "public static short stop = 23;", "optb": "protected short stop = 23;", "optc": "transient short stop = 23;", "optd": "final void madness(short stop);", "ans": "A", "explanation": "(A) is valid interface declarations.\n(B) and (C) are incorrect because interface variables cannot be either protected or transient. (D) is incorrect because interface methods cannot be final or static."}, {"question": "What will be the output of the program?\npublic class Foo \n{  \n    public static void main(String[] args) \n    {\n        try \n        { \n            return; \n        } \n        finally \n        {\n            System.out.println( \"Finally\" ); \n        } \n    } \n}", "opta": "Finally", "optb": "Compilation fails.", "optc": "The code runs with no output.", "optd": "An exception is thrown at runtime.", "ans": "A", "explanation": "If you put a finally block after a try and its associated catch blocks, then once execution enters the try block, the code in that finally block will definitely be executed except in the following circumstances:\n\nAn exception arising in the finally block itself.\nThe death of the thread.\nThe use of System.exit()\nTurning off the power to the CPU.\n\nI suppose the last three could be classified as VM shutdown."}, {"question": "What will be the output of the program?\ntry \n{ \n    int x = 0; \n    int y = 5 / x; \n} \ncatch (Exception e) \n{\n    System.out.println(\"Exception\"); \n} \ncatch (ArithmeticException ae) \n{\n    System.out.println(\" Arithmetic Exception\"); \n} \nSystem.out.println(\"finished\");", "opta": "finished", "optb": "Exception", "optc": "Compilation fails.", "optd": "Arithmetic Exception", "ans": "C", "explanation": "Compilation fails because ArithmeticException has already been caught. ArithmeticException is a subclass of java.lang.Exception, by time the ArithmeticException has been specified it has already been caught by the Exception class.\nIf ArithmeticException appears before Exception, then the file will compile. When catching exceptions the more specific exceptions must be listed before the more general (the subclasses must be caught before the superclasses)."}, {"question": "What will be the output of the program?\npublic class X \n{  \n    public static void main(String [] args) \n    {\n        try \n        {\n            badMethod();  \n            System.out.print(\"A\"); \n        }  \n        catch (Exception ex) \n        {\n            System.out.print(\"B\");  \n        } \n        finally \n        {\n            System.out.print(\"C\"); \n        } \n        System.out.print(\"D\"); \n    }  \n    public static void badMethod() \n    {\n        throw new Error(); /* Line 22 */\n    } \n}", "opta": "ABCD", "optb": "Compilation fails.", "optc": "C is printed before exiting with an error message.", "optd": "BC is printed before exiting with an error message.", "ans": "C", "explanation": "Error is thrown but not recognised line(22) because the only catch attempts to catch an Exception and Exception is not a superclass of Error. Therefore only the code in the finally statement can be run before exiting with a runtime error (Exception in thread \"main\" java.lang.Error)."}, {"question": "What will be the output of the program?\npublic class X \n{  \n    public static void main(String [] args) \n    {\n        try \n        {\n            badMethod();  \n            System.out.print(\"A\");  \n        } \n        catch (RuntimeException ex) /* Line 10 */\n        { \n            System.out.print(\"B\"); \n        } \n        catch (Exception ex1) \n        { \n            System.out.print(\"C\"); \n        } \n        finally \n        {\n            System.out.print(\"D\"); \n        } \n        System.out.print(\"E\"); \n    } \n    public static void badMethod() \n    { \n        throw new RuntimeException(); \n    } \n}", "opta": "BD", "optb": "BCD", "optc": "BDE", "optd": "BCDE", "ans": "C", "explanation": "A Run time exception is thrown and caught in the catch statement on line 10. All the code after the finally statement is run because the exception has been caught."}, {"question": "What will be the output of the program?\npublic class RTExcept \n{\n    public static void throwit () \n    {\n        System.out.print(\"throwit \");\n        throw new RuntimeException();\n    }\n    public static void main(String [] args) \n    {\n        try \n        {\n            System.out.print(\"hello \");\n            throwit();\n        }\n        catch (Exception re ) \n        {\n            System.out.print(\"caught \");\n        }\n        finally \n        {\n            System.out.print(\"finally \");\n        }\n        System.out.println(\"after \");\n    }\n}", "opta": "hello throwit caught", "optb": "Compilation fails", "optc": "hello throwit RuntimeException caught after", "optd": "hello throwit caught finally after", "ans": "D", "explanation": "The main() method properly catches and handles the RuntimeException in the catch block, finally runs (as it always does), and then the code returns to normal.\nA, B and C are incorrect based on the program logic described above. Remember that properly handled exceptions do not cause the program to stop executing."}, {"question": "What will be the output of the program?\npublic class Test \n{  \n    public static void aMethod() throws Exception \n    {\n        try /* Line 5 */\n        {\n            throw new Exception(); /* Line 7 */\n        } \n        finally /* Line 9 */\n        {\n            System.out.print(\"finally \"); /* Line 11 */\n        } \n    } \n    public static void main(String args[]) \n    {\n        try \n        {\n            aMethod();  \n        } \n        catch (Exception e) /* Line 20 */\n        {\n            System.out.print(\"exception \"); \n        } \n        System.out.print(\"finished\"); /* Line 24 */\n    } \n}", "opta": "finally", "optb": "exception finished", "optc": "finally exception finished", "optd": "Compilation fails", "ans": "C", "explanation": "This is what happens: \n(1) The execution of the try block (line 5) completes abruptly because of the throw statement (line 7).\n(2) The exception cannot be assigned to the parameter of any catch clause of the try statement therefore the finally block is executed (line 9) and \"finally\" is output (line 11).\n(3) The finally block completes normally, and then the try statement completes abruptly because of the throw statement (line 7).\n(4) The exception is propagated up the call stack and is caught by the catch in the main method (line 20). This prints \"exception\".\n(5) Lastly program execution continues, because the exception has been caught, and \"finished\" is output (line 24)."}, {"question": "What will be the output of the program?\npublic class X \n{ \n    public static void main(String [] args) \n    {\n        try \n        {\n            badMethod();  \n            System.out.print(\"A\"); \n        }  \n        catch (Exception ex) \n        {\n            System.out.print(\"B\"); \n        }  \n        finally \n        {\n            System.out.print(\"C\"); \n        }  \n        System.out.print(\"D\"); \n    }  \n    public static void badMethod() {} \n}", "opta": "AC", "optb": "BC", "optc": "ACD", "optd": "ABCD", "ans": "C", "explanation": "There is no exception thrown, so all the code with the exception of the catch statement block is run."}, {"question": "What will be the output of the program?\npublic class X \n{  \n    public static void main(String [] args) \n    {\n        try \n        {\n            badMethod(); /* Line 7 */\n            System.out.print(\"A\"); \n        } \n        catch (Exception ex) /* Line 10 */\n        {\n            System.out.print(\"B\"); /* Line 12 */\n        } \n        finally /* Line 14 */\n        {\n            System.out.print(\"C\"); /* Line 16 */\n        }  \n        System.out.print(\"D\"); /* Line 18 */\n    } \n    public static void badMethod() \n    {\n        throw new RuntimeException(); \n    } \n}", "opta": "AB", "optb": "BC", "optc": "ABC", "optd": "BCD", "ans": "D", "explanation": "(1) A RuntimeException is thrown, this is a subclass of exception.\n(2) The exception causes the try to complete abruptly (line 7) therefore line 8 is never executed.\n(3) The exception is caught (line 10) and \"B\" is output (line 12)\n(4) The finally block (line 14) is always executed and \"C\" is output (line 16).\n(5) The exception was caught, so the program continues with line 18 and outputs \"D\"."}, {"question": "What will be the output of the program?\npublic class MyProgram \n{\n    public static void main(String args[])\n    {\n        try \n        {\n            System.out.print(\"Hello world \");\n        }\n        finally \n        {\n            System.out.println(\"Finally executing \");\n        }\n    }\n}", "opta": "Nothing. The program will not compile because no exceptions are specified.", "optb": "Nothing. The program will not compile because no catch clauses are specified.", "optc": "Hello world.", "optd": "Hello world Finally executing", "ans": "D", "explanation": "Finally clauses are always executed. The program will first execute the try block, printing Hello world, and will then execute the finally block, printing Finally executing.\nOption A, B, and C are incorrect based on the program logic described above. Remember that either a catch or a finally statement must follow a try. Since the finally is present, the catch is not required."}, {"question": "What will be the output of the program?\nclass Exc0 extends Exception { } \nclass Exc1 extends Exc0 { } /* Line 2 */\npublic class Test \n{  \n    public static void main(String args[]) \n    { \n        try \n        {  \n            throw new Exc1(); /* Line 9 */\n        } \n        catch (Exc0 e0) /* Line 11 */\n        {\n            System.out.println(\"Ex0 caught\"); \n        } \n        catch (Exception e) \n        {\n            System.out.println(\"exception caught\");  \n        } \n    } \n}", "opta": "Ex0 caught", "optb": "exception caught", "optc": "Compilation fails because of an error at line 2.", "optd": "Compilation fails because of an error at line 9.", "ans": "A", "explanation": "An exception Exc1 is thrown and is caught by the catch statement on line 11. The code is executed in this block. There is no finally block of code to execute."}, {"question": "public void foo( boolean a, boolean b)\n{ \n    if( a ) \n    {\n        System.out.println(\"A\"); /* Line 5 */\n    } \n    else if(a && b) /* Line 7 */\n    { \n        System.out.println( \"A && B\"); \n    } \n    else /* Line 11 */\n    { \n        if ( !b ) \n        {\n            System.out.println( \"notB\") ;\n        } \n        else \n        {\n            System.out.println( \"ELSE\" ) ; \n        } \n    } \n}", "opta": "If a is true and b is true then the output is \"A && B\"", "optb": "If a is true and b is false then the output is \"notB\"", "optc": "If a is false and b is true then the output is \"ELSE\"", "optd": "If a is false and b is false then the output is \"ELSE\"", "ans": "C", "explanation": "Option C is correct. The output is \"ELSE\". Only when a is false do the output lines after 11 get some chance of executing.\nOption A is wrong. The output is \"A\". When a is true, irrespective of the value of b, only the line 5 output will be executed. The condition at line 7 will never be evaluated (when a is true it will always be trapped by the line 12 condition) therefore the output will never be \"A && B\". \nOption B is wrong. The output is \"A\". When a is true, irrespective of the value of b, only the line 5 output will be executed. \nOption D is wrong. The output is \"notB\"."}, {"question": "switch(x) \n{ \n    default:  \n        System.out.println(\"Hello\"); \n}\n\nWhich two are acceptable types for x?\n\nbyte\nlong\nchar\nfloat\nShort\nLong", "opta": "1 and 3", "optb": "2 and 4", "optc": "3 and 5", "optd": "4 and 6", "ans": "A", "explanation": "Switch statements are based on integer expressions and since both bytes and chars can implicitly be widened to an integer, these can also be used. Also shorts can be used. Short and Long are wrapper classes and reference types can not be used as variables."}, {"question": "public void test(int x) \n{ \n    int odd = 1; \n    if(odd) /* Line 4 */\n    {\n        System.out.println(\"odd\"); \n    } \n    else \n    {\n        System.out.println(\"even\"); \n    } \n}\n\nWhich statement is true?", "opta": "Compilation fails.", "optb": "\"odd\" will always be output.", "optc": "\"even\" will always be output.", "optd": "\"odd\" will be output for odd values of x, and \"even\" for even values.", "ans": "A", "explanation": "The compiler will complain because of incompatible types (line 4), the if expects a boolean but it gets an integer."}, {"question": "public class While \n{\n    public void loop() \n    {\n        int x= 0;\n        while ( 1 ) /* Line 6 */\n        {\n            System.out.print(\"x plus one is \" + (x + 1)); /* Line 8 */\n        }\n    }\n}\n\nWhich statement is true?", "opta": "There is a syntax error on line 1.", "optb": "There are syntax errors on lines 1 and 6.", "optc": "There are syntax errors on lines 1, 6, and 8.", "optd": "There is a syntax error on line 6.", "ans": "D", "explanation": "Using the integer 1 in the while statement, or any other looping or conditional construct for that matter, will result in a compiler error. This is old C Program syntax, not valid Java.\nA, B and C are incorrect because line 1 is valid (Java is case sensitive so While is a valid class name). Line 8 is also valid because an equation may be placed in a String operation as shown."}, {"question": "void start() {  \n    A a = new A(); \n    B b = new B(); \n    a.s(b);  \n    b = null; /* Line 5 */\n    a = null;  /* Line 6 */\n    System.out.println(\"start completed\"); /* Line 7 */\n} \n\nWhen is the B object, created in line 3, eligible for garbage collection?", "opta": "after line 5", "optb": "after line 6", "optc": "after line 7", "optd": "There is no way to be absolutely certain.", "ans": "D", "explanation": "No answer description available for this question. Let us discuss."}, {"question": "class HappyGarbage01 \n{ \n    public static void main(String args[]) \n    {\n        HappyGarbage01 h = new HappyGarbage01(); \n        h.methodA(); /* Line 6 */\n    } \n    Object methodA() \n    {\n        Object obj1 = new Object(); \n        Object [] obj2 = new Object[1]; \n        obj2[0] = obj1; \n        obj1 = null; \n        return obj2[0]; \n    } \n}\n\nWhere will be the most chance of the garbage collector being invoked?", "opta": "After line 9", "optb": "After line 10", "optc": "After line 11", "optd": "Garbage collector never invoked in methodA()", "ans": "D", "explanation": "Option D is correct. Garbage collection takes place after the method has returned its reference to the object. The method returns to line 6, there is no reference to store the return value. so garbage collection takes place after line 6. \nOption A is wrong. Because the reference to obj1 is stored in obj2[0]. The Object obj1 still exists on the heap and can be accessed by an active thread through the reference stored in obj2[0]. \nOption B is wrong. Because it is only one of the references to the object obj1, the other reference is maintained in obj2[0]. \nOption C is wrong. The garbage collector will not be called here because a reference to the object is being maintained and returned in obj2[0]."}, {"question": "class Bar { } \nclass Test \n{  \n    Bar doBar() \n    {\n        Bar b = new Bar(); /* Line 6 */\n        return b; /* Line 7 */\n    } \n    public static void main (String args[]) \n    { \n        Test t = new Test();  /* Line 11 */\n        Bar newBar = t.doBar();  /* Line 12 */\n        System.out.println(\"newBar\"); \n        newBar = new Bar(); /* Line 14 */\n        System.out.println(\"finishing\"); /* Line 15 */\n    } \n}\n\nAt what point is the Bar object, created on line 6, eligible for garbage collection?", "opta": "after line 12", "optb": "after line 14", "optc": "after line 7, when doBar() completes", "optd": "after line 15, when main() completes", "ans": "B", "explanation": "Option B is correct. All references to the Bar object created on line 6 are destroyed when a new reference to a new Bar object is assigned to the variable newBar on line 14. Therefore the Bar object, created on line 6, is eligible for garbage collection after line 14. \nOption A is wrong. This actually protects the object from garbage collection.\nOption C is wrong. Because the reference in the doBar() method is returned on line 7 and is stored in newBar on line 12. This preserver the object created on line 6. \nOption D is wrong. Not applicable because the object is eligible for garbage collection after line 14."}, {"question": "class Test \n{  \n    private Demo d; \n    void start() \n    {  \n        d = new Demo(); \n        this.takeDemo(d); /* Line 7 */\n    } /* Line 8 */\n    void takeDemo(Demo demo) \n    { \n        demo = null;  \n        demo = new Demo(); \n    } \n}\n\nWhen is the Demo object eligible for garbage collection?", "opta": "After line 7", "optb": "After line 8", "optc": "After the start() method completes", "optd": "When the instance running this code is made eligible for garbage collection.", "ans": "D", "explanation": "Option D is correct. By a process of elimination.\nOption A is wrong. The variable d is a member of the Test class and is never directly set to null. \nOption B is wrong. A copy of the variable d is set to null and not the actual variable d. \nOption C is wrong. The variable d exists outside the start() method (it is a class member). So, when the start() method finishes the variable d still holds a reference."}, {"question": "public class X \n{\n    public static void main(String [] args) \n    {\n        X x = new X();\n        X x2 = m1(x); /* Line 6 */\n        X x4 = new X();\n        x2 = x4; /* Line 8 */\n        doComplexStuff();\n    }\n    static X m1(X mx) \n    {\n        mx = new X();\n        return mx;\n    }\n}\n\nAfter line 8 runs. how many objects are eligible for garbage collection?", "opta": "0", "optb": "1", "optc": "2", "optd": "3", "ans": "B", "explanation": "By the time line 8 has run, the only object without a reference is the one generated as a result of line 6. Remember that \"Java is pass by value,\" so the reference variable x is not affected by the m1() method.\nRef: http://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html"}, {"question": "public Object m() \n{  \n    Object o = new Float(3.14F); \n    Object [] oa = new Object[l];\n    oa[0] = o; /* Line 5 */\n    o = null;  /* Line 6 */\n    oa[0] = null; /* Line 7 */\n    return o; /* Line 8 */\n}\n\nWhen is the Float object, created in line 3, eligible for garbage collection?", "opta": "just after line 5", "optb": "just after line 6", "optc": "just after line 7", "optd": "just after line 8", "ans": "C", "explanation": "Option A is wrong. This simply copies the object reference into the array.\nOption B is wrong. The reference o is set to null, but, oa[0] still maintains the reference to the Float object.\nOption C is correct. The thread of execution will then not have access to the object."}, {"question": "class X2 \r\n{\r\n    public X2 x;\r\n    public static void main(String [] args) \r\n    {\r\n        X2 x2 = new X2();  /* Line 6 */\r\n        X2 x3 = new X2();  /* Line 7 */\r\n        x2.x = x3;\r\n        x3.x = x2;\r\n        x2 = new X2();\r\n        x3 = x2; /* Line 11 */\r\n        doComplexStuff();\r\n    }\r\n}\r\n\r\nafter line 11 runs, how many objects are eligible for garbage collection?", "opta": "0", "optb": "1", "optc": "2", "optd": "3", "ans": "C", "explanation": "This is an example of the islands of isolated objects. By the time line 11 has run, the objects instantiated in lines 6 and 7 are referring to each other, but no live thread can reach either of them."}, {"question": "What allows the programmer to destroy an object x?", "opta": "x.delete()", "optb": "x.finalize()", "optc": "Runtime.getRuntime().gc()", "optd": "Only the garbage collection system can destroy an object.", "ans": "D", "explanation": "Option D is correct. When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded. \nOption A is wrong. I found 4 delete() methods in all of the Java class structure. They are:\n\n\ndelete() - Method in class java.io.File : Deletes the file or directory denoted by this abstract pathname.\ndelete(int, int) - Method in class java.lang.StringBuffer : Removes the characters in a substring of this StringBuffer.\ndelete(int, int) - Method in interface javax.accessibility.AccessibleEditableText : Deletes the text between two indices\ndelete(int, int) - Method in class : javax.swing.text.JTextComponent.AccessibleJTextComponent; Deletes the text between two indices\n\n\nNone of these destroy the object to which they belong. \nOption B is wrong. I found 19 finalize() methods. The most interesting, from this questions point of view, was the finalize() method in class java.lang.Object which is called by the garbage collector on an object when garbage collection determines that there are no more references to the object. This method does not destroy the object to which it belongs. \nOption C is wrong. But it is interesting. The Runtime class has many methods, two of which are: \n\n\ngetRuntime() - Returns the runtime object associated with the current Java application.\ngc() - Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects. Interesting as this is, it doesn't destroy the object."}, {"question": "Which is true about an anonymous inner class?", "opta": "It can extend exactly one class and implement exactly one interface.", "optb": "It can extend exactly one class and can implement multiple interfaces.", "optc": "It can extend exactly one class or implement exactly one interface.", "optd": "It can implement multiple interfaces regardless of whether it also extends a class.", "ans": "C", "explanation": "Option C is correct because the syntax of an anonymous inner class allows for only one named type after the new, and that type must be either a single interface (in which case the anonymous class implements that one interface) or a single class (in which case the anonymous class extends that one class).\nOption A, B, D, and E are all incorrect because they don't follow the syntax rules described in the response for answer Option C."}, {"question": "class Boo \n{\n    Boo(String s) { }\n    Boo() { }\n}\nclass Bar extends Boo \n{\n    Bar() { }\n    Bar(String s) {super(s);}\n    void zoo() \n    {\n    // insert code here\n    }\n}\n\nwhich one create an anonymous inner class from within class Bar?", "opta": "Boo f = new Boo(24) { };", "optb": "Boo f = new Bar() { };", "optc": "Bar f = new Boo(String s) { };", "optd": "Boo f = new Boo.Bar(String s) { };", "ans": "B", "explanation": "Option B is correct because anonymous inner classes are no different from any other class when it comes to polymorphism. That means you are always allowed to declare a reference variable of the superclass type and have that reference variable refer to an instance of a subclass type, which in this case is an anonymous subclass of Bar. Since Bar is a subclass of Boo, it all works.\nOption A is incorrect because it passes an int to the Boo constructor, and there is no matching constructor in the Boo class.\nOption C is incorrect because it violates the rules of polymorphism\u2014you cannot refer to a superclass type using a reference variable declared as the subclass type. The superclass is not guaranteed to have everything the subclass has.\nOption D uses incorrect syntax."}, {"question": "Which is true about a method-local inner class?", "opta": "It must be marked final.", "optb": "It can be marked abstract.", "optc": "It can be marked public.", "optd": "It can be marked static.", "ans": "B", "explanation": "Option B is correct because a method-local inner class can be abstract, although it means a subclass of the inner class must be created if the abstract class is to be used (so an abstract method-local inner class is probably not useful).\nOption A is incorrect because a method-local inner class does not have to be declared final (although it is legal to do so).\nC and D are incorrect because a method-local inner class cannot be made public (remember-you cannot mark any local variables as public), or static."}, {"question": "Which statement is true about a static nested class?", "opta": "You must have a reference to an instance of the enclosing class in order to instantiate it.", "optb": "It does not have access to nonstatic members of the enclosing class.", "optc": "It's variables and methods must be static.", "optd": "It must extend the enclosing class.", "ans": "B", "explanation": "Option B is correct because a static nested class is not tied to an instance of the enclosing class, and thus can't access the nonstatic members of the class (just as a static method can't access nonstatic members of a class).\nOption A is incorrect because static nested classes do not need (and can't use) a reference to an instance of the enclosing class.\nOption C is incorrect because static nested classes can declare and define nonstatic members.\nOption D is wrong because it just is. There's no rule that says an inner or nested class has to extend anything."}, {"question": "Which constructs an anonymous inner class instance?", "opta": "Runnable r = new Runnable() { };", "optb": "Runnable r = new Runnable(public void run() { });", "optc": "Runnable r = new Runnable { public void run(){}};", "optd": "System.out.println(new Runnable() {public void run() { }});", "ans": "D", "explanation": "D is correct. It defines an anonymous inner class instance, which also means it creates an instance of that new anonymous class at the same time. The anonymous class is an implementer of the Runnable interface, so it must override the run() method of Runnable.\nA is incorrect because it doesn't override the run() method, so it violates the rules of interface implementation.\nB and C use incorrect syntax."}, {"question": "class Foo \n{\n    class Bar{ }\n}\nclass Test \n{\n    public static void main (String [] args) \n    {\n        Foo f = new Foo();\n        /* Line 10: Missing statement ? */\n    }\n}\n\nwhich statement, inserted at line 10, creates an instance of Bar?", "opta": "Foo.Bar b = new Foo.Bar();", "optb": "Foo.Bar b = f.new Bar();", "optc": "Bar b = new f.Bar();", "optd": "Bar b = f.new Bar();", "ans": "B", "explanation": "Option B is correct because the syntax is correct-using both names (the enclosing class and the inner class) in the reference declaration, then using a reference to the enclosing class to invoke new on the inner class.\nOption A, C and D all use incorrect syntax. A is incorrect because it doesn't use a reference to the enclosing class, and also because it includes both names in the new.\nC is incorrect because it doesn't use the enclosing class name in the reference variable declaration, and because the new syntax is wrong.\nD is incorrect because it doesn't use the enclosing class name in the reference variable declaration."}, {"question": "public class MyOuter \n{\n    public static class MyInner \n    {\n        public static void foo() { }\n    }\n}\n \nwhich statement, if placed in a class other than MyOuter or MyInner, instantiates an instance of the nested class?", "opta": "MyOuter.MyInner m = new MyOuter.MyInner();", "optb": "MyOuter.MyInner mi = new MyInner();", "optc": "MyOuter m = new MyOuter();MyOuter.MyInner mi = m.new MyOuter.MyInner();", "optd": "MyInner mi = new MyOuter.MyInner();", "ans": "A", "explanation": "MyInner is a static nested class, so it must be instantiated using the fully-scoped name of MyOuter.MyInner.\nOption B is incorrect because it doesn't use the enclosing name in the new.\nOption C is incorrect because it uses incorrect syntax. When you instantiate a nested class by invoking new on an instance of the enclosing class, you do not use the enclosing name. The difference between Option A and C is that Option C is calling new on an instance of the enclosing class rather than just new by itself. \nOption D is incorrect because it doesn't use the enclosing class name in the variable declaration."}, {"question": "What is the value of \"d\" after this line of code has been executed?\ndouble d = Math.round ( 2.5 + Math.random() );", "opta": "2", "optb": "3", "optc": "4", "optd": "2.5", "ans": "B", "explanation": "The Math.random() method returns a number greater than or equal to 0 and less than 1 . Since we can then be sure that the sum of that number and 2.5 will be greater than or equal to 2.5 and less than 3.5, we can be sure that Math.round() will round that number to 3. So Option B is the answer."}, {"question": "Which of the following would compile without error?", "opta": "int a = Math.abs(-5);", "optb": "int b = Math.abs(5.0);", "optc": "int c = Math.abs(5.5F);", "optd": "int d = Math.abs(5L);", "ans": "A", "explanation": "The return value of the Math.abs() method is always the same as the type of the parameter passed into that method.\nIn the case of A, an integer is passed in and so the result is also an integer which is fine for assignment to \"int a\".\nThe values used in B, C & D respectively are a double, a float and a long. The compiler will complain about a possible loss of precision if we try to assign the results to an \"int\"."}, {"question": "Which of the following are valid calls to Math.max?\n\nMath.max(1,4)\nMath.max(2.3, 5)\nMath.max(1, 3, 5, 7)\nMath.max(-1.5, -2.8f)", "opta": "1, 2 and 4", "optb": "2, 3 and 4", "optc": "1, 2 and 3", "optd": "3 and 4", "ans": "A", "explanation": "(1), (2), and (4) are correct. The max() method is overloaded to take two arguments of type int, long, float, or double.\n(3) is incorrect because the max() method only takes two arguments."}, {"question": "public class Myfile \n{ \n    public static void main (String[] args) \n    {\n        String biz = args[1]; \n        String baz = args[2]; \n        String rip = args[3]; \n        System.out.println(\"Arg is \" + rip); \n    } \n}\n\nSelect how you would start the program to cause it to print: Arg is 2", "opta": "java Myfile 222", "optb": "java Myfile 1 2 2 3 4", "optc": "java Myfile 1 3 2 2", "optd": "java Myfile 0 1 2 3", "ans": "C", "explanation": "Arguments start at array element 0 so the fourth arguement must be 2 to produce the correct output."}, {"question": "Which four options describe the correct default values for array elements of the types indicated?\n\nint -> 0\nString -> \"null\"\nDog -> null\nchar -> '\\u0000'\nfloat -> 0.0f\nboolean -> true", "opta": "1, 2, 3, 4", "optb": "1, 3, 4, 5", "optc": "2, 4, 5, 6", "optd": "3, 4, 5, 6", "ans": "B", "explanation": "(1), (3), (4), (5) are the correct statements.\n(2) is wrong because the default value for a String (and any other object reference) is null, with no quotes.\n(6) is wrong because the default value for boolean elements is false."}, {"question": "Which one of these lists contains only Java programming language keywords?", "opta": "class, if, void, long, Int, continue", "optb": "goto, instanceof, native, finally, default, throws", "optc": "try, virtual, throw, final, volatile, transient", "optd": "strictfp, constant, super, implements, do", "opte": "byte, break, assert, switch, include", "ans": "B", "explanation": "All the words in option B are among the 49 Java keywords. Although goto reserved as a keyword in Java, goto is not used and has no function.\nOption A is wrong because the keyword for the primitive int starts with a lowercase i.\nOption C is wrong because \"virtual\" is a keyword in C++, but not Java.\nOption D is wrong because \"constant\" is not a keyword. Constants in Java are marked static and final.\nOption E is wrong because \"include\" is a keyword in C, but not in  Java."}, {"question": "Which will legally declare, construct, and initialize an array?", "opta": "int [] myList = {\"1\", \"2\", \"3\"};", "optb": "int [] myList = (5, 8, 2);", "optc": "int myList [] [] = {4,9,7,0};", "optd": "int myList [] = {4, 3, 7};", "ans": "D", "explanation": "The only legal array declaration and assignment statement is Option D\nOption A is wrong because it initializes an int array with String literals.\nOption B is wrong because it use something other than curly braces for the initialization.\nOption C is wrong because it provides initial values for only one dimension, although the declared array is a two-dimensional array."}, {"question": "Which is a reserved word in the Java programming language?", "opta": "method", "optb": "native", "optc": "subclasses", "optd": "reference", "opte": "array", "ans": "B", "explanation": "The word \"native\" is a valid keyword, used to modify a method declaration.\nOption A, D and E are not keywords. Option C is wrong because the keyword for subclassing in Java is extends, not 'subclasses'."}, {"question": "Which is a valid keyword in java?", "opta": "interface", "optb": "string", "optc": "Float", "optd": "unsigned", "ans": "A", "explanation": "interface is a valid keyword.\nOption B is wrong because although \"String\" is a class type in Java, \"string\" is not a keyword.\nOption C is wrong because \"Float\" is a class type. The keyword for the Java primitive is float.\nOption D is wrong because \"unsigned\" is a keyword in C/C++ but not in Java."}, {"question": "Which three are legal array declarations?\n\nint [] myScores [];\nchar [] myChars;\nint [6] myScores;\nDog myDogs [];\nDog myDogs [7];", "opta": "1, 2, 4", "optb": "2, 4, 5", "optc": "2, 3, 4", "optd": "All are correct.", "ans": "A", "explanation": "(1), (2), and (4) are legal array declarations. With an array declaration, you can place the brackets to the right or left of the identifier. Option A looks strange, but it's perfectly legal to split the brackets in a multidimensional array, and place them on both sides of the identifier. Although coding this way would only annoy your fellow programmers, for the exam, you need to know it's legal.\n(3) and (5) are wrong because you can't declare an array with a size. The size is only needed when the array is actually instantiated (and the JVM needs to know how much space to allocate for the array, based on the type of array and the size)."}, {"question": "public interface Foo \n{ \n    int k = 4; /* Line 3 */\n}\n\nWhich three piece of codes are equivalent to line 3?\n\nfinal int k = 4;\npublic int k = 4;\nstatic int k = 4;\nabstract int k = 4;\nvolatile int k = 4;\nprotected int k = 4;", "opta": "1, 2 and 3", "optb": "2, 3 and 4", "optc": "3, 4 and 5", "optd": "4, 5 and 6", "ans": "A", "explanation": "(1), (2) and (3) are correct. Interfaces can have constants, which are always implicitly public, static, and final. Interface constant declarations of public, static, and final are optional in any combination."}, {"question": "Which one of the following will declare an array and initialize it with five numbers?", "opta": "Array a = new Array(5);", "optb": "int [] a = {23,22,21,20,19};", "optc": "int a [] = new int[5];", "optd": "int [5] array;", "ans": "B", "explanation": "Option B is the legal way to declare and initialize an array with five elements.\nOption A is wrong because it shows an example of instantiating a class named Array, passing the integer value 5 to the object's constructor. If you don't see the brackets, you can be certain there is no actual array object! In other words, an Array object (instance of class Array) is not the same as an array object.\nOption C is wrong because it shows a legal array declaration, but with no initialization.\nOption D is wrong (and will not compile) because it declares an array with a size. Arrays must never be given a size when declared."}, {"question": "Which three are valid declarations of a char?\n\nchar c1 = 064770;\nchar c2 = 'face';\nchar c3 = 0xbeef;\nchar c4 = \\u0022;\nchar c5 = '\\iface';\nchar c6 = '\\uface';", "opta": "1, 2, 4", "optb": "1, 3, 6", "optc": "3, 5", "optd": "5 only", "ans": "B", "explanation": "(1), (3), and (6) are correct. char c1 = 064770; is an octal representation of the integer value 27128, which is legal because it fits into an unsigned 16-bit integer. char c3 = 0xbeef; is a hexadecimal representation of the integer value 48879, which fits into an unsigned 16-bit integer. char c6 = '\\uface'; is a Unicode representation of a character.\n\nchar c2 = 'face'; is wrong because you can't put more than one character in a char literal. The only other acceptable char literal that can go between single quotes is a Unicode value, and Unicode literals must always start with a '\\u'.\nchar c4 = \\u0022; is wrong because the single quotes are missing.\nchar c5 = '\\iface'; is wrong because it appears to be a Unicode representation (notice the backslash), but starts with '\\i' rather than '\\u'."}, {"question": "Which is the valid declarations within an interface definition?", "opta": "public double methoda();", "optb": "public final double methoda();", "optc": "static void methoda(double d1);", "optd": "protected void methoda(double d1);", "ans": "A", "explanation": "Option A is correct. A public access modifier is acceptable. The method prototypes in an interface are all abstract by virtue of their declaration, and should not be declared abstract.\nOption B is wrong. The final modifier means that this method cannot be constructed in a subclass. A final method cannot be abstract. \nOption C is wrong. static is concerned with the class and not an instance. \nOption D is wrong. protected is not permitted when declaring a method of an interface. See information below. \nMember declarations in an interface disallow the use of some declaration modifiers; you cannot use transient, volatile, or synchronized in a member declaration in an interface. Also, you may not use the private and protected specifiers when declaring members of an interface."}, {"question": "Which one is a valid declaration of a boolean?", "opta": "boolean b1 = 0;", "optb": "boolean b2 = 'false';", "optc": "boolean b3 = false;", "optd": "boolean b4 = Boolean.false();", "opte": "boolean b5 = no;", "ans": "C", "explanation": "A boolean can only be assigned the literal true or false."}, {"question": "Which three are valid declarations of a float?\n\nfloat f1 = -343;\nfloat f2 = 3.14;\nfloat f3 = 0x12345;\nfloat f4 = 42e7;\nfloat f5 = 2001.0D;\nfloat f6 = 2.81F;", "opta": "1, 2, 4", "optb": "2, 3, 5", "optc": "1, 3, 6", "optd": "2, 4, 6", "ans": "C", "explanation": "(1) and (3) are integer literals (32 bits), and integers can be legally assigned to floats (also 32 bits). (6) is correct because (F) is appended to the literal, declaring it as a float rather than a double (the default for floating point literals).\n(2), (4),and (5) are all doubles."}, {"question": "Which is a valid declarations of a String?", "opta": "String s1 = null;", "optb": "String s2 = 'null';", "optc": "String s3 = (String) 'abc';", "optd": "String s4 = (String) '\\ufeed';", "ans": "A", "explanation": "Option A sets the String reference to null.\nOption B is wrong because null cannot be in single quotes.\nOption C is wrong because there are multiple characters between the single quotes ('abc').\nOption D is wrong because you can't cast a char (primitive) to a String (object)."}, {"question": "What is the numerical range of a char?", "opta": "-128 to 127", "optb": "-(215) to (215) - 1", "optc": "0 to 32767", "optd": "0 to 65535", "ans": "D", "explanation": "A char is really a 16-bit integer behind the scenes, so it supports 216 (from 0 to 65535) values."}, {"question": "Suppose that you would like to create an instance of a new Map that has an iteration order that is the same as the iteration order of an existing instance of a Map. Which concrete implementation of the Map interface should be used for the new instance?", "opta": "TreeMap", "optb": "HashMap", "optc": "LinkedHashMap", "optd": "The answer depends on the implementation of the existing instance.", "ans": "C", "explanation": "The iteration order of a Collection is the order in which an iterator moves through the elements of the Collection. The iteration order of a LinkedHashMap is determined by the order in which elements are inserted. \nWhen a new LinkedHashMap is created by passing a reference to an existing Collection to the constructor of a LinkedHashMap the Collection.addAll method will ultimately be invoked. \nThe addAll method uses an iterator to the existing Collection to iterate through the elements of the existing Collection and add each to the instance of the new LinkedHashMap. \nSince the iteration order of the LinkedHashMap is determined by the order of insertion, the iteration order of the new LinkedHashMap must be the same as the interation order of the old Collection."}, {"question": "Which class does not override the equals() and hashCode() methods, inheriting them directly from class Object?", "opta": "java.lang.String", "optb": "java.lang.Double", "optc": "java.lang.StringBuffer", "optd": "java.lang.Character", "ans": "C", "explanation": "java.lang.StringBuffer is the only class in the list that uses the default methods provided by class Object."}, {"question": "Which collection class allows you to grow or shrink its size and provides indexed access to its elements, but whose methods are not synchronized?", "opta": "java.util.HashSet", "optb": "java.util.LinkedHashSet", "optc": "java.util.List", "optd": "java.util.ArrayList", "ans": "D", "explanation": "All of the collection classes allow you to grow or shrink the size of your collection. ArrayList provides an index to its elements. The newer collection classes tend not to have synchronized methods. Vector is an older implementation of ArrayList functionality and has synchronized methods; it is slower than ArrayList."}, {"question": "You need to store elements in a collection that guarantees that no duplicates are stored and all elements can be accessed in natural order. Which interface provides that capability?", "opta": "java.util.Map", "optb": "java.util.Set", "optc": "java.util.List", "optd": "java.util.Collection", "ans": "B", "explanation": "Option B is correct. A set is a collection that contains no duplicate elements. The iterator returns the elements in no particular order (unless this set is an instance of some class that provides a guarantee). A map cannot contain duplicate keys but it may contain duplicate values. List and Collection allow duplicate elements. \nOption A is wrong. A map is an object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the TreeMap class, make specific guarantees as to their order (ascending key order); others, like the HashMap class, do not (does not guarantee that the order will remain constant over time).\nOption C is wrong. A list is an ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.\nOption D is wrong. A collection is also known as a sequence. The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements."}, {"question": "Which interface does java.util.Hashtable implement?", "opta": "Java.util.Map", "optb": "Java.util.List", "optc": "Java.util.HashTable", "optd": "Java.util.Collection", "ans": "A", "explanation": "Hash table based implementation of the Map interface."}, {"question": "Which interface provides the capability to store objects using a key-value pair?", "opta": "Java.util.Map", "optb": "Java.util.Set", "optc": "Java.util.List", "optd": "Java.util.Collection", "ans": "A", "explanation": "An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value."}, {"question": "Which collection class allows you to associate its elements with key values, and allows you to retrieve objects in FIFO (first-in, first-out) sequence?", "opta": "java.util.ArrayList", "optb": "java.util.LinkedHashMap", "optc": "java.util.HashMap", "optd": "java.util.TreeMap", "ans": "B", "explanation": "LinkedHashMap is the collection class used for caching purposes. FIFO is another way to indicate caching behavior. To retrieve LinkedHashMap elements in cached order, use the values() method and iterate over the resultant collection."}, {"question": "Which collection class allows you to access its elements by associating a key with an element's value, and provides synchronization?", "opta": "java.util.SortedMap", "optb": "java.util.TreeMap", "optc": "java.util.TreeSet", "optd": "java.util.Hashtable", "ans": "D", "explanation": "Hashtable is the only class listed that provides synchronized methods. If you need synchronization great; otherwise, use HashMap, it's faster."}, {"question": "Which is valid declaration of a float?", "opta": "float f = 1F;", "optb": "float f = 1.0;", "optc": "float f = \"1\";", "optd": "float f = 1.0d;", "ans": "A", "explanation": "Option A is valid declaration of float.\nOption B is incorrect because any literal number with a decimal point u declare the computer will implicitly cast to double unless you include \"F or f\"\nOption C is incorrect because it is a String.\nOption D is incorrect because \"d\" tells the computer it is a double so therefore you are trying to put a double value into a float variable i.e there might be a loss of precision."}, {"question": "/* Missing Statement ? */\npublic class foo \n{\n    public static void main(String[]args)throws Exception \n    {\n        java.io.PrintWriter out = new java.io.PrintWriter(); \n        new java.io.OutputStreamWriter(System.out,true); \n        out.println(\"Hello\"); \n    } \n}\n\nWhat line of code should replace the missing statement to make this program compile?", "opta": "No statement required.", "optb": "import java.io.*;", "optc": "include java.io.*;", "optd": "import java.io.PrintWriter;", "ans": "A", "explanation": "The usual method for using/importing the java packages/classes is by using an import statement at the top of your code. However it is possible to explicitly import the specific class that you want to use as you use it which is shown in the code above. The disadvantage of this however is that every time you create a new object you will have to use the class path in the case \"java.io\" then the class name in the long run leading to a lot more typing."}, {"question": "What is the numerical range of char?", "opta": "0 to 32767", "optb": "0 to 65535", "optc": "-256 to 255", "optd": "-32768 to 32767", "ans": "B", "explanation": "The char type is integral but unsigned. The range of a variable of type char is from 0 to 216-1 or 0 to 65535. Java characters are Unicode, which is a 16-bit encoding capable of representing a wide range of international characters. If the most significant nine bits of a char are 0, then the encoding is the same as seven-bit ASCII."}, {"question": "Which of the following are Java reserved words?\n\nrun\nimport\ndefault\nimplement", "opta": "1 and 2", "optb": "2 and 3", "optc": "3 and 4", "optd": "2 and 4", "ans": "B", "explanation": "(2) - This is a Java keyword\n(3) - This is a Java keyword \n(1) - Is incorrect because although it is a method of Thread/Runnable it is not a keyword \n(4) - This is not a Java keyword the keyword is implements"}, {"question": "What will be the output of the program?\nclass PassA \n{\n    public static void main(String [] args) \n    {\n        PassA p = new PassA();\n        p.start();\n    }\n\n    void start() \n    {\n        long [] a1 = {3,4,5};\n        long [] a2 = fix(a1);\n        System.out.print(a1[0] + a1[1] + a1[2] + \" \");\n        System.out.println(a2[0] + a2[1] + a2[2]);\n    }\n\n    long [] fix(long [] a3) \n    {\n        a3[1] = 7;\n        return a3;\n    }\n}", "opta": "12 15", "optb": "15 15", "optc": "3 4 5 3 7 5", "optd": "3 7 5 3 7 5", "ans": "B", "explanation": "Output: 15 15\nThe reference variables a1 and a3 refer to the same long array object. When the [1] element is updated in the fix() method, it is updating the array referred to by a1. The reference variable a2 refers to the same array object.\nSo Output: 3+7+5+\" \"3+7+5\nOutput: 15 15 Because Numeric values will be added"}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        Test p = new Test();\n        p.start();\n    }\n\n    void start() \n    {\n        boolean b1 = false;\n        boolean b2 = fix(b1);\n        System.out.println(b1 + \" \" + b2);\n    }\n\n    boolean fix(boolean b1) \n    {\n        b1 = true;\n        return b1;\n    }\n}", "opta": "true true", "optb": "false true", "optc": "true false", "optd": "false false", "ans": "B", "explanation": "The boolean b1 in the fix() method is a different boolean than the b1 in the start() method. The b1 in the start() method is not updated by the fix() method."}, {"question": "What will be the output of the program?\nclass PassS \n{\n    public static void main(String [] args) \n    {\n        PassS p = new PassS();\n        p.start();\n    }\n\n    void start() \n    {\n        String s1 = \"slip\";\n        String s2 = fix(s1);\n        System.out.println(s1 + \" \" + s2);\n    }\n\n    String fix(String s1) \n    {\n        s1 = s1 + \"stream\";\n        System.out.print(s1 + \" \");\n        return \"stream\";\n    }\n}", "opta": "slip stream", "optb": "slipstream stream", "optc": "stream slip stream", "optd": "slipstream slip stream", "ans": "D", "explanation": "When the fix() method is first entered, start()'s s1 and fix()'s s1 reference variables both refer to the same String object (with a value of \"slip\"). Fix()'s s1 is reassigned to a new object that is created when the concatenation occurs (this second String object has a value of \"slipstream\"). When the program returns to start(), another String object is created, referred to by s2 and with a value of \"stream\"."}, {"question": "What will be the output of the program?\nclass BitShift \n{\n    public static void main(String [] args) \n    {\n        int x = 0x80000000;\n        System.out.print(x + \" and  \");\n        x = x >>> 31;\n        System.out.println(x);\n    }\n}", "opta": "-2147483648 and 1", "optb": "0x80000000 and 0x00000001", "optc": "-2147483648 and -1", "optd": "1 and -2147483648", "ans": "A", "explanation": "Option A is correct. The >>> operator moves all bits to the right, zero filling the left bits. The bit transformation looks like this:\nBefore: 1000 0000 0000 0000 0000 0000 0000 0000\nAfter: 0000 0000 0000 0000 0000 0000 0000 0001\nOption C is incorrect because the >>> operator zero fills the left bits, which in this case changes the sign of x, as shown.\nOption B is incorrect because the output method print() always displays integers in base 10.\nOption D is incorrect because this is the reverse order of the two output numbers."}, {"question": "What will be the output of the program?\nclass Equals \n{\n    public static void main(String [] args) \n    {\n        int x = 100;\n        double y = 100.1;\n        boolean b = (x = y); /* Line 7 */\n        System.out.println(b);\n    }\n}", "opta": "true", "optb": "false", "optc": "Compilation fails", "optd": "An exception is thrown at runtime", "ans": "C", "explanation": "The code will not compile because in line 7, the line will work only if we use (x==y) in the line. The == operator compares values to produce a boolean, whereas the = operator assigns a value to variables.\nOption A, B, and D are incorrect because the code does not get as far as compiling. If we corrected this code, the output would be false."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x=20;\n        String sup = (x < 15) ? \"small\" : (x < 22)? \"tiny\" : \"huge\";\n        System.out.println(sup);\n    }\n}", "opta": "small", "optb": "tiny", "optc": "huge", "optd": "Compilation fails", "ans": "B", "explanation": "This is an example of a nested ternary operator. The second evaluation (x < 22) is true, so the \"tiny\" value is assigned to sup."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x= 0;\n        int y= 0;\n        for (int z = 0; z < 5; z++) \n        {\n            if (( ++x > 2 ) && (++y > 2)) \n            {\n                x++;\n            }\n        }\n        System.out.println(x + \" \" + y);\n    }\n}", "opta": "5 2", "optb": "5 3", "optc": "6 3", "optd": "6 4", "ans": "C", "explanation": "In the first two iterations x is incremented once and y is not because of the short circuit && operator. In the third and forth iterations x and y are each incremented, and in the fifth iteration x is doubly incremented and y is incremented."}, {"question": "What will be the output of the program?\nclass Test \n{\n    public static void main(String [] args) \n    {\n        int x= 0;\n        int y= 0;\n        for (int z = 0; z < 5; z++) \n        {\n            if (( ++x > 2 ) || (++y > 2)) \n            {\n                x++;\n            }\n        }\n    System.out.println(x + \" \" + y);\n    }\n}", "opta": "5 3", "optb": "8 2", "optc": "8 3", "optd": "8 5", "ans": "B", "explanation": "The first two iterations of the for loop both x and y are incremented. On the third iteration x is incremented, and for the first time becomes greater than 2. The short circuit or operator || keeps y from ever being incremented again and x is incremented twice on each of the last three iterations."}, {"question": "What will be the output of the program?\nclass Bitwise \n{\n    public static void main(String [] args) \n    {\n        int x = 11 & 9;\n        int y = x ^ 3;\n        System.out.println( y | 12 );\n    }\n}", "opta": "0", "optb": "7", "optc": "8", "optd": "14", "ans": "D", "explanation": "The & operator produces a 1 bit when both bits are 1. The result of the & operation is 9. The ^ operator produces a 1 bit when exactly one bit is 1; the result of this operation is 10. The | operator produces a 1 bit when at least one bit is 1; the result of this operation is 14."}, {"question": "What will be the output of the program?\nclass SSBool \n{\n    public static void main(String [] args) \n    {\n        boolean b1 = true;\n        boolean b2 = false;\n        boolean b3 = true;\n        if ( b1 & b2 | b2 & b3 | b2 ) /* Line 8 */\n            System.out.print(\"ok \");\n        if ( b1 & b2 | b2 & b3 | b2 | b1 ) /*Line 10*/\n            System.out.println(\"dokey\");\n    }\n}", "opta": "ok", "optb": "dokey", "optc": "ok dokey", "optd": "No output is produced", "opte": "Compilation error", "ans": "B", "explanation": "The & operator has a higher precedence than the | operator so that on line 8 b1 and b2 are evaluated together as are b2 & b3. The final b1 in line 10 is what causes that if test to be true. Hence it prints \"dokey\"."}, {"question": "What will be the output of the program?\nclass SC2 \n{\n    public static void main(String [] args) \n    {\n        SC2 s = new SC2();\n        s.start();\n    }\n\n    void start() \n    {\n        int a = 3;\n        int b = 4;\n        System.out.print(\" \" + 7 + 2 + \" \");\n        System.out.print(a + b);\n        System.out.print(\" \" + a + b + \" \");\n        System.out.print(foo() + a + b + \" \");\n        System.out.println(a + b + foo());\n    }\n\n    String foo() \n    {\n        return \"foo\";\n    }\n}", "opta": "9 7 7 foo 7 7foo", "optb": "72 34 34 foo34 34foo", "optc": "9 7 7 foo34 34foo", "optd": "72 7 34 foo34 7foo", "ans": "D", "explanation": "Because all of these expressions use the + operator, there is no precedence to worry about and all of the expressions will be evaluated from left to right. If either operand being evaluated is a String, the + operator will concatenate the two operands; if both operands are numeric, the + operator will add the two operands."}, {"question": "What will be the output of the program?\nclass Test \n{\n    static int s;\n    public static void main(String [] args) \n    {\n        Test p = new Test();\n        p.start();\n        System.out.println(s);\n    }\n\n    void start() \n    {\n        int x = 7;\n        twice(x);\n        System.out.print(x + \" \");\n    }\n\n    void twice(int x) \n    {\n        x = x*2;\n        s = x;\n    }\n}", "opta": "7 7", "optb": "7 14", "optc": "14 0", "optd": "14 14", "ans": "B", "explanation": "The int x in the twice() method is not the same int x as in the start() method. Start()'s x is not affected by the twice() method. The instance variable s is updated by twice()'s x, which is 14."}, {"question": "What will be the output of the program?\nclass Two \n{\n    byte x;\n}\n\nclass PassO \n{\n    public static void main(String [] args) \n    {\n        PassO p = new PassO();\n        p.start();\n    }\n\n    void start() \n    {\n        Two t = new Two();\n        System.out.print(t.x + \" \");\n        Two t2 = fix(t);\n        System.out.println(t.x + \" \" + t2.x);\n    }\n\n    Two fix(Two tt) \n    {\n        tt.x = 42;\n        return tt;\n    }\n}", "opta": "null null 42", "optb": "0 0 42", "optc": "0 42 42", "optd": "0 0 0", "ans": "C", "explanation": "In the fix() method, the reference variable tt refers to the same object (class Two) as the t reference variable. Updating tt.x in the fix() method updates t.x (they are one in the same object). Remember also that the instance variable x in the Two class is initialized to 0."}, {"question": "What will be the output of the program?\nclass BoolArray \n{\n    boolean [] b = new boolean[3];\n    int count = 0;\n\n    void set(boolean [] x, int i) \n    {\n        x[i] = true;\n        ++count;\n    }\n\n    public static void main(String [] args) \n    {\n        BoolArray ba = new BoolArray();\n        ba.set(ba.b, 0);\n        ba.set(ba.b, 2);\n        ba.test();\n    }\n\n    void test() \n    {\n        if ( b[0] && b[1] | b[2] )\n            count++;\n        if ( b[1] && b[(++count - 2)] )\n            count += 7;\n        System.out.println(\"count = \" + count);\n    }\n}", "opta": "count = 0", "optb": "count = 2", "optc": "count = 3", "optd": "count = 4", "ans": "C", "explanation": "The reference variables b and x both refer to the same boolean array. count is incremented for each call to the set() method, and once again when the first if test is true. Because of the && short circuit operator, count is not incremented during the second if test."}, {"question": "What will be the output of the program?\npublic class Test \n{ \n    public static void leftshift(int i, int j) \n    {\n        i <<= j; \n    } \n    public static void main(String args[]) \n    {\n        int i = 4, j = 2; \n        leftshift(i, j); \n        System.out.printIn(i); \n    } \n}", "opta": "2", "optb": "4", "optc": "8", "optd": "16", "ans": "B", "explanation": "Java only ever passes arguments to a method by value (i.e. a copy of the variable) and never by reference. Therefore the value of the variable i remains unchanged in the main method.\nIf you are clever you will spot that 16 is 4 multiplied by 2 twice, (4 * 2 * 2) = 16. If you had 16 left shifted by three bits then 16 * 2 * 2 * 2 = 128. If you had 128 right shifted by 2 bits then 128 / 2 / 2 = 32. Keeping these points in mind, you don't have to go converting to binary to do the left and right bit shifts."}, {"question": "What is the name of the method used to start a thread execution?", "opta": "init();", "optb": "start();", "optc": "run();", "optd": "resume();", "ans": "B", "explanation": "Option B is Correct. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread. \nOption A is wrong. There is no init() method in the Thread class.\nOption C is wrong. The run() method of a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption D is wrong. The resume() method is deprecated. It resumes a suspended thread."}, {"question": "Which two are valid constructors for Thread?\n\nThread(Runnable r, String name)\nThread()\nThread(int priority)\nThread(Runnable r, ThreadGroup g)\nThread(Runnable r, int priority)", "opta": "1 and 3", "optb": "2 and 4", "optc": "1 and 2", "optd": "2 and 5", "ans": "C", "explanation": "(1) and (2) are both valid constructors for Thread.\n(3), (4), and (5) are not legal Thread constructors, although (4) is close. If you reverse the arguments in (4), you'd have a valid constructor."}, {"question": "Which three are methods of the Object class?\n\nnotify();\nnotifyAll();\nisInterrupted();\nsynchronized();\ninterrupt();\nwait(long msecs);\nsleep(long msecs);\nyield();", "opta": "1, 2, 4", "optb": "2, 4, 5", "optc": "1, 2, 6", "optd": "2, 3, 4", "ans": "C", "explanation": "(1), (2), and (6) are correct. They are all related to the list of threads waiting on the specified object.\n(3), (5), (7), and (8) are incorrect answers. The methods isInterrupted() and interrupt() are instance methods of Thread. \nThe methods sleep() and yield() are static methods of Thread. \nD is incorrect because synchronized is a keyword and the synchronized() construct is part of the Java language."}, {"question": "class X implements Runnable \n{ \n    public static void main(String args[]) \n    {\n        /* Missing code? */\n    } \n    public void run() {} \n}\n\nWhich of the following line of code is suitable to start a thread ?", "opta": "Thread t = new Thread(X);", "optb": "Thread t = new Thread(X); t.start();", "optc": "X run = new X(); Thread t = new Thread(run); t.start();", "optd": "Thread t = new Thread(); x.run();", "ans": "C", "explanation": "Option C is suitable to start a thread."}, {"question": "Which cannot directly cause a thread to stop executing?", "opta": "Calling the SetPriority() method on a Thread object.", "optb": "Calling the wait() method on an object.", "optc": "Calling notify() method on an object.", "optd": "Calling read() method on an InputStream object.", "ans": "C", "explanation": "Option C is correct. notify() - wakes up a single thread that is waiting on this object's monitor."}, {"question": "Which two of the following methods are defined in class Thread?\n\nstart()\nwait()\nnotify()\nrun()\nterminate()", "opta": "1 and 4", "optb": "2 and 3", "optc": "3 and 4", "optd": "2 and 4", "ans": "A", "explanation": "(1) and (4). Only start() and run() are defined by the Thread class.\n(2) and (3) are incorrect because they are methods of the Object class. (5) is incorrect because there's no such method in any thread-related class."}, {"question": "Which three guarantee that a thread will leave the running state?\n\nyield()\nwait()\nnotify()\nnotifyAll()\nsleep(1000)\naLiveThread.join()\nThread.killThread()", "opta": "1, 2 and 4", "optb": "2, 5 and 6", "optc": "3, 4 and 7", "optd": "4, 5 and 7", "ans": "B", "explanation": "(2) is correct because wait() always causes the current thread to go into the object's wait pool. \n(5) is correct because sleep() will always pause the currently running thread for at least the duration specified in the sleep argument (unless an interrupted exception is thrown). \n(6) is correct because, assuming that the thread you're calling join() on is alive, the thread calling join() will immediately block until the thread you're calling join() on is no longer alive.\n(1) is wrong, but tempting. The yield() method is not guaranteed to cause a thread to leave the running state, although if there are runnable threads of the same priority as the currently running thread, then the current thread will probably leave the running state. \n(3) and (4) are incorrect because they don't cause the thread invoking them to leave the running state.\n(7) is wrong because there's no such method."}, {"question": "Which of the following will directly stop the execution of a Thread?", "opta": "wait()", "optb": "notify()", "optc": "notifyall()", "optd": "exits synchronized code", "ans": "A", "explanation": "Option A is correct. wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.\nOption B is wrong. notify() - wakes up a single thread that is waiting on this object's monitor. \nOption C is wrong. notifyAll() - wakes up all threads that are waiting on this object's monitor.\nOption D is wrong. Typically, releasing a lock means the thread holding the lock (in other words, the thread currently in the synchronized method) exits the synchronized method. At that point, the lock is free until some other thread enters a synchronized method on that object. Does entering/exiting synchronized code mean that the thread execution stops? Not necessarily because the thread can still run code that is not synchronized. I think the word directly in the question gives us a clue. Exiting synchronized code does not directly stop the execution of a thread."}, {"question": "Which method must be defined by a class implementing the java.lang.Runnable interface?", "opta": "void run()", "optb": "public void run()", "optc": "public void start()", "optd": "void run(int priority)", "ans": "B", "explanation": "Option B is correct because in an interface all methods are abstract by default therefore they must be overridden by the implementing class. The Runnable interface only contains 1 method, the void run() method therefore it must be implemented. \nOption A and D are incorrect because they are narrowing the access privileges i.e. package(default) access is narrower than public access. \nOption C is not method in the Runnable interface therefore it is incorrect."}, {"question": "Which will contain the body of the thread?", "opta": "run();", "optb": "start();", "optc": "stop();", "optd": "main();", "ans": "A", "explanation": "Option A is Correct. The run() method to a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption B is wrong. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread. \nOption C is wrong. The stop() method is deprecated. It forces the thread to stop executing. \nOption D is wrong. Is the main entry point for an application."}, {"question": "Which method registers a thread in a thread scheduler?", "opta": "run();", "optb": "construct();", "optc": "start();", "optd": "register();", "ans": "C", "explanation": "Option C is correct. The start() method causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.\nOption A is wrong. The run() method of a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.\nOption B is wrong. There is no construct() method in the Thread class.\nOption D is wrong. There is no register() method in the Thread class."}, {"question": "Assume the following method is properly synchronized and called from a thread A on an object B:\nwait(2000);\nAfter calling this method, when will the thread A become a candidate to get another turn at the CPU?", "opta": "After thread A is notified, or after two seconds.", "optb": "After the lock on B is released, or after two seconds.", "optc": "Two seconds after thread A is notified.", "optd": "Two seconds after lock B is released.", "ans": "A", "explanation": "Option A. Either of the two events (notification or wait time expiration) will make the thread become a candidate for running again.\nOption B is incorrect because a waiting thread will not return to runnable when the lock is released, unless a notification occurs.\nOption C is incorrect because the thread will become a candidate immediately after notification, not two seconds afterwards. \nOption D is also incorrect because a thread will not come out of a waiting pool just because a lock has been released."}, {"question": "Which of the following will not directly cause a thread to stop?", "opta": "notify()", "optb": "wait()", "optc": "InputStream access", "optd": "sleep()", "ans": "A", "explanation": "Option A is correct. notify() - wakes up a single thread that is waiting on this object's monitor.\nOption B is wrong. wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. \nOption C is wrong. Methods of the InputStream class block until input data is available, the end of the stream is detected, or an exception is thrown. Blocking means that a thread may stop until certain conditions are met.\nOption D is wrong. sleep() - Causes the currently executing thread to sleep (temporarily cease execution) for a specified number of milliseconds. The thread does not lose ownership of any monitors."}, {"question": "Which class or interface defines the wait(), notify(),and notifyAll() methods?", "opta": "Object", "optb": "Thread", "optc": "Runnable", "optd": "Class", "ans": "A", "explanation": "The Object class defines these thread-specific methods.\nOption B, C, and D are incorrect because they do not define these methods. And yes, the Java API does define a class called Class, though you do not need to know it for the exam."}, {"question": "public class MyRunnable implements Runnable \n{\n    public void run() \n    {\n        // some code here\n    }\n}\n\nwhich of these will create and start this thread?", "opta": "new Runnable(MyRunnable).start();", "optb": "new Thread(MyRunnable).run();", "optc": "new Thread(new MyRunnable()).start();", "optd": "new MyRunnable().start();", "ans": "C", "explanation": "Because the class implements Runnable, an instance of it has to be passed to the Thread constructor, and then the instance of the Thread has to be started.\nA is incorrect. There is no constructor like this for Runnable because Runnable is an interface, and it is illegal to pass a class or interface name to any constructor.\nB is incorrect for the same reason; you can't pass a class or interface name to any constructor.\nD is incorrect because MyRunnable doesn't have a start() method, and the only start() method that can start a thread of execution is the start() in the Thread class."}]]}